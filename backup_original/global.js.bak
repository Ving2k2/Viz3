// ============================================================================
// GLOBAL CONFLICT MAP VISUALIZATION - MAP VIEW
// Uses shared.js for common constants and utilities
// ============================================================================

// Note: CSV_FILE_PATH, REGION_COLORS, TYPE_MAP, TYPE_COLORS are defined in shared.js

// === GLOBAL STATE ===
let rawData = [];
let processedData = [];
let countryData = new Map();
let activeRegions = Object.keys(REGION_COLORS);
let worldMapFeatures = null; // Store world map features for neighbor detection
let provinceFeatures = null; // Store province/state features for borders
// === USE SHARED VIEW STATE MANAGER ===
const viewState = viewStateManager.getState();

// Push current state to history before transitioning
function pushViewHistory() {
    viewStateManager.pushHistory();
}

// Unified back navigation - returns true if navigated, false if at root
function navigateBack() {
    // Priority 1: If event is selected, deselect event (stay in country view)
    if (viewState.selectedEvent && viewState.mode === 'event') {
        viewState.selectedEvent = null;
        viewState.mode = 'country';

        // Redraw bubbles without event selection
        bubblesGroup.selectAll(".event-bubble")
            .classed("selected-event", false)
            .classed("unselected-event", false)
            .style("opacity", 0.8);

        // Show country charts again
        if (viewState.selectedCountryData) {
            updateAllCharts();
            updateLeftPanel();
        }
        return true;
    }

    // Priority 2: If in country view, return to region or world
    if (viewState.mode === 'country') {
        if (viewState.selectedRegion) {
            // Return to region view
            exitToRegionView();
        } else {
            // Return to world view
            returnToWorldView();
        }
        return true;
    }

    // Priority 3: If in region view, return to world view
    if (viewState.mode === 'region') {
        returnToWorldView();
        return true;
    }

    // Already at world view - hide back button
    d3.select("#reset-zoom").style("display", "none");
    return false;
}

// Exit from country view back to region view
function exitToRegionView() {
    if (!viewState.selectedRegion) {
        returnToWorldView();
        return;
    }

    // Reset country state but keep region
    viewState.mode = 'region';
    viewState.selectedCountryName = null;
    viewState.selectedCountryData = null;
    viewState.selectedEvent = null;

    // Reset zoom
    svg.transition()
        .duration(500)
        .call(zoom.transform, d3.zoomIdentity);

    // Clear event bubbles
    bubblesGroup.selectAll(".event-bubble").remove();
    bubblesGroup.selectAll(".capital-marker").remove();

    // Restore region view
    setTimeout(() => {
        toggleRegion(viewState.selectedRegion);
    }, 100);
}

// === D3 SELECTIONS ===
let mapWidth, mapHeight;
const svg = d3.select("#world-map");
const container = svg.append("g");
const mapGroup = container.append("g").attr("class", "map-group");
const bubblesGroup = container.append("g").attr("class", "bubbles-group");

let projection, path, zoom;

// === PERFORMANCE OPTIMIZATION ===
let lastEventSelectTime = 0;
let cachedVictimChartSVG = null;
let cachedVictimChartG = null;
let graphViewActive = false; // Track if graph view is active (for global.html, always false)

// ============================================================================
// INITIALIZATION & RESPONSIVE
// ============================================================================

// Debounce utility function for performance optimization

function initializeMap() {
    const mapSection = document.querySelector('.map-section');
    mapWidth = mapSection.clientWidth;
    mapHeight = mapSection.clientHeight;

    svg.attr("width", mapWidth).attr("height", mapHeight);

    // Initialize rendering engine with projection
    const result = renderingEngine.initialize(mapWidth, mapHeight);
    projection = result.projection;
    path = result.path;

    // Debounced zoom update for better performance
    const debouncedZoomUpdate = debounce(() => {
        if (viewState.mode === 'region') {
            updateRegionBubbles();
        } else if (viewState.mode === 'world') {
            updateWorldBubbles();
        } else if (viewState.mode === 'country') {
            updateCapitalMarkerSize();
        }
    }, 50);

    zoom = d3.zoom()
        .scaleExtent([1, 500])
        .on("zoom", (event) => {
            container.attr("transform", event.transform);
            viewState.zoomScale = event.transform.k;
            debouncedZoomUpdate();
        });

    svg.call(zoom);

    // Initialize Time Slider logic
    createTimeSlider();
    setupModal();
    setupBackButton();
    setupViewToggle(); // Initialize view mode toggle buttons
}

window.addEventListener('resize', () => {
    initializeMap();
    if (viewState.mode === 'world') {
        drawWorldMap();
        drawConflictBubbles();
        renderTopCountriesList();
    } else if (viewState.mode === 'country') {
        drawIndividualEventBubbles();
        updateAllCharts();
        updateLeftPanel();
    } else if (viewState.mode === 'region') {
        toggleRegion(viewState.selectedRegion);
    } else if (viewState.mode === 'event') {
        renderEventDetailsView(viewState.selectedEvent);
    }
});

// ============================================================================
// DATA PROCESSING
// ============================================================================



async function loadData() {
    try {
        const data = await d3.csv(CSV_FILE_PATH);
        // Use shared processRawData
        rawData = processRawData(data);

        // Initialize data filter manager
        dataFilterManager.initialize(rawData);

        // Use aggregationManager
        processedData = aggregationManager.aggregateByCountry(rawData, countryData);

        updateStats();
        createLegend();
        createViolenceTypeFilter();

        // Initialize slider range based on data
        const years = rawData.map(d => d.year);
        const minYear = d3.min(years);
        const maxYear = d3.max(years);

        const slider = document.getElementById('year-slider');
        if (slider) {
            slider.min = minYear;
            slider.max = maxYear;
            slider.value = maxYear;
            document.getElementById('year-start').textContent = minYear;
            document.getElementById('year-end').textContent = maxYear;
            document.getElementById('year-current').textContent = maxYear;
        }


    } catch (error) {
        console.error("❌ Error loading data:", error);
    }
}

// Diagnostic function to verify all countries can be mapped
function verifyCountryMappings() {
    if (!worldMapFeatures || !processedData) {
        console.warn("⚠️ Cannot verify mappings - map or data not loaded yet");
        return;
    }

    const mapCountryNames = worldMapFeatures.map(f => f.properties.name);
    const unmappedCountries = [];
    const mappedCountries = [];



    processedData.forEach(countryData => {
        const countryName = countryData.name;

        // Check exact match
        if (mapCountryNames.includes(countryName)) {
            mappedCountries.push(countryName);
            return;
        }

        // Check normalized match
        const normalize = (str) => str.toLowerCase()
            .replace(/\bthe\b/g, '')
            .replace(/\brepublic of\b/g, '')
            .replace(/\bdemocratic republic of\b/g, '')
            .replace(/\bkingdom of\b/g, '')
            .replace(/\./g, '')
            .replace(/\s+/g, ' ')
            .trim();

        const normalizedTarget = normalize(countryName);
        const normalizedMatch = mapCountryNames.find(name => normalize(name) === normalizedTarget);

        if (normalizedMatch) {
            mappedCountries.push(countryName);
            return;
        }

        // Check manual mapping (from handleBubbleClick function)
        const manualMapping = {
            // Historical/Political name changes
            "Cambodia (Kampuchea)": "Cambodia",
            "Kampuchea": "Cambodia",
            "DR Congo (Zaire)": "Dem. Rep. Congo",
            "DR Congo": "Dem. Rep. Congo",
            "Democratic Republic of the Congo": "Dem. Rep. Congo",
            "Congo, DR": "Dem. Rep. Congo",
            "Zaire": "Dem. Rep. Congo",
            "Myanmar (Burma)": "Myanmar",
            "Burma": "Myanmar",
            "Zimbabwe (Rhodesia)": "Zimbabwe",
            "Rhodesia": "Zimbabwe",
            "Yemen (North Yemen)": "Yemen",
            "Russia (Soviet Union)": "Russia",
            "Soviet Union": "Russia",
            "USSR": "Russia",
            "Serbia (Yugoslavia)": "Serbia",
            "Yugoslavia": "Serbia",
            "Serbia and Montenegro": "Serbia",
            "Federal Republic of Yugoslavia": "Serbia",
            "Bosnia-Herzegovina": "Bosnia and Herz.",
            "Bosnia and Herzegovina": "Bosnia and Herz.",
            "Bosnia": "Bosnia and Herz.",
            "Montenegro": "Montenegro",
            "Macedonia": "North Macedonia",
            "FYROM": "North Macedonia",
            "Ivory Coast": "Côte d'Ivoire",
            "East Timor": "Timor-Leste",
            "Timor-Leste (East Timor)": "Timor-Leste",
            "Laos": "Lao PDR",
            "Vietnam": "Vietnam",
            "Viet Nam": "Vietnam",
            "North Korea": "Dem. Rep. Korea",
            "South Korea": "Korea",
            "Central African Republic": "Central African Rep.",
            "Dominican Republic": "Dominican Rep.",
            "South Sudan": "S. Sudan",
            "Czech Republic": "Czechia",
            "United States": "United States of America",
            "USA": "United States of America",
            "Eswatini": "eSwatini",
            "Swaziland": "eSwatini",

            // === FIX FOR 6 UNMAPPED COUNTRIES ===
            "Bahrain": "Bahrain",
            "Comoros": "Comoros",
            "Kingdom of eSwatini (Swaziland)": "eSwatini",
            "Madagascar (Malagasy)": "Madagascar",
            "Malagasy": "Madagascar",
            "North Macedonia": "North Macedonia",
            "Solomon Islands": "Solomon Is."
        };

        if (manualMapping[countryName] && mapCountryNames.includes(manualMapping[countryName])) {
            mappedCountries.push(countryName);
            return;
        }

        // If we got here, country is unmapped
        unmappedCountries.push(countryName);
    });



    if (unmappedCountries.length > 0) {
        console.warn(`⚠️ UNMAPPED COUNTRIES (${unmappedCountries.length}):`, unmappedCountries.sort());


        // Automatically search for possible matches
        findMapNamesForUnmapped(unmappedCountries);
    } else {

    }

    return {
        total: processedData.length,
        mapped: mappedCountries.length,
        unmapped: unmappedCountries
    };
}

// Helper function to find exact map names for unmapped countries
function findMapNamesForUnmapped(unmappedCountries) {
    if (!worldMapFeatures) {
        console.warn("⚠️ Map not loaded yet");
        return;
    }

    const mapCountryNames = worldMapFeatures.map(f => f.properties.name);



    unmappedCountries.forEach(countryName => {


        // Find similar names
        const similar = mapCountryNames.filter(mapName => {
            const lowerCountry = countryName.toLowerCase();
            const lowerMap = mapName.toLowerCase();

            // Check if either contains the other, or if they share significant words
            const words = lowerCountry.split(/\s+/);
            const mapWords = lowerMap.split(/\s+/);

            return words.some(word => word.length > 3 && lowerMap.includes(word)) ||
                mapWords.some(word => word.length > 3 && lowerCountry.includes(word));
        });

        if (similar.length > 0) {

        } else {

        }
    });


}


function updateStats() {
    const currentYear = +document.getElementById('year-slider').value;

    // Use dataFilterManager for optimized filtering with caching
    let filterOptions = { year: currentYear };

    // Add violence type filter if selected
    if (viewState.selectedViolenceType) {
        filterOptions.violenceType = viewState.selectedViolenceType;
    }

    let filteredData;

    // Filter by region if selected
    if (viewState.selectedRegion) {
        filteredData = dataFilterManager.getRegionEvents(viewState.selectedRegion, filterOptions);
    } else if (viewState.mode === 'country' && viewState.selectedCountryName) {
        // Filter by selected country in country view
        filteredData = dataFilterManager.getCountryEvents(viewState.selectedCountryName, filterOptions);
    } else {
        filterOptions.regions = activeRegions;
        filteredData = dataFilterManager.filter(filterOptions);
    }

    const totalEvents = filteredData.length;
    const totalCasualties = d3.sum(filteredData, d => d.best);

    d3.select("#total-events").text(d3.format(",d")(totalEvents));
    d3.select("#total-casualties").text(d3.format(",d")(totalCasualties));

    // Draw regional stacked bars (only in world view AND when no specific region is selected)
    if (viewState.mode === 'world' && !viewState.selectedRegion) {
        drawRegionalStackedBars(filteredData);
    } else if (viewState.mode === 'region' && viewState.selectedRegion) {
        // In regional view, show violence type stacked chart
        drawViolenceTypeStackedChart(filteredData);
    } else {
        d3.select("#regional-bars").remove();
    }
}

// ============================================================================
// MAP RENDERING
// ============================================================================

async function drawWorldMap() {
    // Use renderingEngine for map rendering
    await renderingEngine.drawWorldMap(mapGroup, handleCountryClick);
    worldMapFeatures = renderingEngine.getWorldMapFeatures();
}

function drawConflictBubbles() {
    // OPTIMIZED: Interrupt existing transitions before starting new ones
    bubblesGroup.selectAll(".conflict-bubble").interrupt();

    const currentYear = +document.getElementById('year-slider').value;

    // Use dataFilterManager for optimized filtering with caching
    const filterOptions = { year: currentYear, regions: activeRegions };
    if (viewState.selectedViolenceType) {
        filterOptions.violenceType = viewState.selectedViolenceType;
    }
    const currentYearData = dataFilterManager.filter(filterOptions);

    const currentCountryData = aggregationManager.aggregateByCountry(currentYearData, countryData);

    let filteredCountries = currentCountryData.filter(d =>
        activeRegions.includes(d.region) && d.coordinates
    );

    // Use renderingEngine to draw bubbles
    renderingEngine.drawConflictBubbles(
        bubblesGroup,
        filteredCountries,
        viewState.zoomScale,
        handleBubbleClick
    );
}

// Helper functions to update bubble sizes on zoom
function updateWorldBubbles() {
    const currentYear = +document.getElementById('year-slider').value;

    // Use dataFilterManager for optimized filtering
    const filterOptions = { year: currentYear, regions: activeRegions };
    if (viewState.selectedViolenceType) {
        filterOptions.violenceType = viewState.selectedViolenceType;
    }
    const currentYearData = dataFilterManager.filter(filterOptions);

    const currentCountryData = aggregationManager.aggregateByCountry(currentYearData, countryData);

    let filteredCountries = currentCountryData.filter(d =>
        activeRegions.includes(d.region) && d.coordinates
    );

    const maxCasualties = d3.max(filteredCountries, d => d.totalCasualties);
    const zoomFactor = viewState.zoomScale;
    const baseRange = [5 / zoomFactor, 40 / zoomFactor];

    const radiusScale = d3.scaleSqrt()
        .domain([0, maxCasualties])
        .range(baseRange);

    bubblesGroup.selectAll(".conflict-bubble")
        .transition()
        .duration(100)
        .attr("r", d => radiusScale(d.totalCasualties));
}

function updateRegionBubbles() {
    if (!viewState.selectedRegion) return;

    const currentYear = +document.getElementById('year-slider').value;

    // Use dataFilterManager for optimized region filtering
    const filterOptions = { year: currentYear };
    if (viewState.selectedViolenceType) {
        filterOptions.violenceType = viewState.selectedViolenceType;
    }
    const currentYearData = dataFilterManager.getRegionEvents(viewState.selectedRegion, filterOptions);
    const currentCountryData = aggregationManager.aggregateByCountry(currentYearData, countryData);

    let filteredCountries = currentCountryData.filter(d => d.coordinates);

    const maxCasualties = d3.max(filteredCountries, d => d.totalCasualties);
    const zoomFactor = viewState.zoomScale || 1;
    const baseRange = [5 / zoomFactor, 40 / zoomFactor];

    const radiusScale = d3.scaleSqrt()
        .domain([0, maxCasualties])
        .range(baseRange);

    bubblesGroup.selectAll(".conflict-bubble")
        .transition()
        .duration(100)
        .attr("r", d => radiusScale(d.totalCasualties));

    updateStats();
}

// ============================================================================
// NEIGHBOR DETECTION
// ============================================================================

function getNeighboringCountries(countryName) {
    // Use renderingEngine for neighbor detection
    return renderingEngine.getNeighboringCountries(countryName);
}


// ============================================================================
// INDIVIDUAL EVENT BUBBLES (Country View)
// ============================================================================

function drawIndividualEventBubbles() {
    if (!viewState.selectedCountryData) return;

    const currentYear = +document.getElementById('year-slider').value;

    // Filter events by year
    let events = viewState.selectedCountryData.eventsWithCoords.filter(e => e.year <= currentYear);

    // Apply violence type filter if active
    if (viewState.selectedViolenceType) {
        events = events.filter(e => e.type_of_violence_name === viewState.selectedViolenceType);
    }

    // Apply faction filter if active
    if (viewState.selectedFaction) {
        events = events.filter(e => {
            const factionName = viewState.selectedFaction;
            const side_a = e.side_a || '';
            const side_b = e.side_b || '';
            // Check if faction appears in either side_a or side_b
            return side_a.includes(factionName) || side_b.includes(factionName);
        });
    }

    const maxCasualties = d3.max(events, d => d.best);
    const zoomFactor = viewState.zoomScale;

    // Scale bubbles inversely with zoom - smaller when zoomed in
    const baseRange = [3 / zoomFactor, 20 / zoomFactor];

    const radiusScale = d3.scaleSqrt()
        .domain([0, maxCasualties])
        .range(baseRange);

    const eventBubbles = bubblesGroup.selectAll(".event-bubble")
        .data(events, (d, i) => `${d.country}-${d.year}-${i}`);

    eventBubbles.exit().remove(); // Remove immediately for performance

    const enter = eventBubbles.enter()
        .append("circle")
        .attr("class", "event-bubble")
        .attr("cx", d => projection([d.longitude, d.latitude])[0])
        .attr("cy", d => projection([d.longitude, d.latitude])[1])
        .attr("r", d => radiusScale(d.best))
        .style("fill", d => TYPE_COLORS[d.type_of_violence_name])
        .style("cursor", "pointer")
        .classed("selected-event", d => viewState.selectedEvent && d === viewState.selectedEvent)
        .classed("unselected-event", d => viewState.selectedEvent && d !== viewState.selectedEvent)
        .on("mouseover", showEventTooltip)
        .on("mouseout", hideEventTooltip)
        .on("click", (event, d) => {
            event.stopPropagation();
            selectEvent(d);
        });

    if (events.length < 500) {
        enter.attr("r", 0)
            .transition()
            .duration(800)
            .attr("r", d => radiusScale(d.best));
    }

    // Update existing bubbles - use classes for selection state
    eventBubbles
        .attr("cx", d => projection([d.longitude, d.latitude])[0])
        .attr("cy", d => projection([d.longitude, d.latitude])[1])
        .attr("r", d => radiusScale(d.best))
        .style("fill", d => TYPE_COLORS[d.type_of_violence_name])
        .classed("selected-event", d => viewState.selectedEvent && d === viewState.selectedEvent)
        .classed("unselected-event", d => viewState.selectedEvent && d !== viewState.selectedEvent);
}

function selectEvent(event) {
    // Debounce: Ignore rapid clicks (within 50ms)
    const now = performance.now();
    if (now - lastEventSelectTime < 50) {
        return;
    }
    lastEventSelectTime = now;

    // Early exit if same event is already selected
    if (viewState.selectedEvent === event) {
        return;
    }

    viewState.selectedEvent = event;

    // OPTIMIZED: Use single batch update with CSS custom property for fast styling
    requestAnimationFrame(() => {
        const bubbles = bubblesGroup.selectAll(".event-bubble");

        // Use D3 data binding to set classes efficiently
        bubbles
            .classed("selected-event", d => d === event)
            .classed("unselected-event", d => d !== event);
    });

    // OPTIMIZED: Defer panel rendering to idle callback or next frame
    // This makes the click feel instant while panel loads in background
    if ('requestIdleCallback' in window) {
        requestIdleCallback(() => {
            renderEventDetailsView(event);
        }, { timeout: 100 });
    } else {
        // Fallback for browsers without requestIdleCallback
        setTimeout(() => {
            requestAnimationFrame(() => {
                renderEventDetailsView(event);
            });
        }, 16);
    }
}

function showEventTooltip(event, d) {
    // Use renderingEngine for tooltip
    renderingEngine.showEventTooltip(event, d);
}

function hideEventTooltip() {
    // Use renderingEngine for tooltip
    renderingEngine.hideEventTooltip();
}

// OPTIMIZED: Render event details in right panel - UNIFIED with graph.js
function renderEventDetailsView(event) {
    if (!event) return;

    // Switch mode to event view
    viewState.mode = 'event';

    // Show right panel if hidden
    const chartsPanel = d3.select("#charts-panel");
    chartsPanel.style("display", "flex");

    // Update panel title
    d3.select("#charts-title").text("Event Details");
    d3.select("#charts-subtitle").text(event.country || "Conflict Event");

    // Hide standard chart containers
    chartsPanel.selectAll(".chart-container").style("display", "none");

    // Clear or create event details container
    let detailsContainer = chartsPanel.select("#event-text-details");
    if (detailsContainer.empty()) {
        detailsContainer = chartsPanel.append("div")
            .attr("id", "event-text-details")
            .attr("class", "chart-container")
            .style("display", "block");
    } else {
        detailsContainer.html('').style("display", "block");
    }

    // Get factions involved in this event (connected factions)
    const connectedFactions = [];
    if (event.side_a) {
        connectedFactions.push({
            name: event.side_a,
            casualties: event.deaths_a || 0,
            relationshipType: 'opponent',
            color: '#ef4444'
        });
    }
    if (event.side_b) {
        connectedFactions.push({
            name: event.side_b,
            casualties: event.deaths_b || 0,
            relationshipType: 'opponent',
            color: '#3b82f6'
        });
    }

    // Get all events in same country for context
    const countryEvents = viewState.selectedCountryData?.eventsWithCoords ||
        rawData.filter(e => e.country === event.country);

    // Use shared renderEntityInfoPanel for unified UI
    renderEntityInfoPanel(detailsContainer, {
        title: "Event Details",
        entityName: event.dyad_name || 'Unknown Conflict',
        entitySubtext: `${event.date_start || event.year} • ${event.type_of_violence_name}`,
        entityColor: TYPE_COLORS[event.type_of_violence_name] || '#64748b',
        events: [event], // Single event for stats
        country: event.country,
        region: event.region,
        connectedEntities: connectedFactions,
        connectedTitle: "Factions Involved",
        showHeatmap: false, // Single event, no heatmap needed
        showViolenceBreakdown: false // Already showing violence type
    });

    // Add casualties breakdown section (unique to event view)
    const panel = detailsContainer.select("div");

    // Casualties breakdown card
    if (event.best > 0) {
        panel.append("h4")
            .style("margin", "1rem 0 0.5rem 0")
            .style("font-size", "0.9rem")
            .style("color", "#475569")
            .text("Casualties Breakdown");

        const breakdownContainer = panel.append("div")
            .style("background", "white")
            .style("border-radius", "6px")
            .style("padding", "0.75rem")
            .style("margin-bottom", "1rem");

        // Visual bar chart
        const barChart = breakdownContainer.append("div")
            .style("height", "24px")
            .style("background", "#e2e8f0")
            .style("border-radius", "4px")
            .style("overflow", "hidden")
            .style("display", "flex")
            .style("margin-bottom", "0.75rem");

        const casualties = [
            { label: `Side A: ${event.side_a || 'Unknown'}`, value: event.deaths_a || 0, color: '#ef4444' },
            { label: `Side B: ${event.side_b || 'Unknown'}`, value: event.deaths_b || 0, color: '#3b82f6' },
            { label: 'Civilians', value: event.deaths_civilians || 0, color: '#dc2626' },
            { label: 'Unknown', value: event.deaths_unknown || 0, color: '#78716c' }
        ].filter(c => c.value > 0);

        casualties.forEach(c => {
            const pct = (c.value / event.best) * 100;
            barChart.append("div")
                .style("width", `${pct}%`)
                .style("height", "100%")
                .style("background", c.color)
                .attr("title", `${c.label}: ${d3.format(",d")(c.value)} (${d3.format(".1%")(c.value / event.best)})`);
        });

        // Detailed breakdown list
        casualties.forEach(c => {
            const pct = (c.value / event.best) * 100;
            const row = breakdownContainer.append("div")
                .style("display", "flex")
                .style("justify-content", "space-between")
                .style("align-items", "center")
                .style("padding", "0.4rem 0")
                .style("border-bottom", "1px solid #f1f5f9");

            row.append("div")
                .style("display", "flex")
                .style("align-items", "center")
                .style("gap", "0.5rem")
                .html(`
                    <div style="width: 10px; height: 10px; background: ${c.color}; border-radius: 2px;"></div>
                    <span style="font-size: 0.8rem; color: #475569;">${c.label}</span>
                `);

            row.append("div")
                .style("text-align", "right")
                .html(`
                    <span style="font-weight: 600; color: #1e293b; font-size: 0.85rem;">${d3.format(",d")(c.value)}</span>
                    <span style="font-size: 0.7rem; color: #94a3b8; margin-left: 0.25rem;">(${d3.format(".0%")(pct / 100)})</span>
                `);
        });
    }

    // Source information
    if (event.source_headline || event.source_article) {
        panel.append("h4")
            .style("margin", "1rem 0 0.5rem 0")
            .style("font-size", "0.9rem")
            .style("color", "#475569")
            .text("Source Information");

        const sourceContainer = panel.append("div")
            .style("background", "rgba(59, 130, 246, 0.05)")
            .style("border-radius", "6px")
            .style("padding", "0.75rem")
            .style("border", "1px solid rgba(59, 130, 246, 0.1)");

        if (event.source_headline) {
            sourceContainer.append("p")
                .style("font-size", "0.85rem")
                .style("color", "#475569")
                .style("font-style", "italic")
                .style("margin-bottom", "0.5rem")
                .text(`"${event.source_headline}"`);
        }

        if (event.source_article) {
            sourceContainer.append("p")
                .style("font-size", "0.75rem")
                .style("color", "#94a3b8")
                .style("line-height", "1.4")
                .text(event.source_article);
        }
    }
}

// ============================================================================
// COUNTRY INTERACTIONS
// ============================================================================

// Helper function to find country feature using comprehensive matching
// Used by both bubble clicks and ranking list clicks
function findCountryFeature(countryName) {
    const allCountryFeatures = mapGroup.selectAll(".country").data();

    // Helper for normalization
    const normalize = str => str.toLowerCase()
        .replace(/\bthe\b/g, '')
        .replace(/\brepublic of\b/g, '')
        .replace(/\./g, '')
        .replace(/\s+/g, ' ')
        .trim();

    // 1. Try exact match
    let countryFeature = allCountryFeatures.find(c => c.properties.name === countryName);
    if (countryFeature) return countryFeature;

    // 2. Try normalized match
    const normalizedTarget = normalize(countryName);
    countryFeature = allCountryFeatures.find(c => normalize(c.properties.name) === normalizedTarget);
    if (countryFeature) return countryFeature;

    // 3. Check manual mapping FIRST (before fuzzy matching)
    const manualMapping = {
        // === HISTORICAL/POLITICAL NAME CHANGES ===
        "Cambodia (Kampuchea)": "Cambodia",
        "Kampuchea": "Cambodia",

        // Congo variations - MUST come before fuzzy matching
        "DR Congo (Zaire)": "Dem. Rep. Congo",
        "DR Congo": "Dem. Rep. Congo",
        "Democratic Republic of the Congo": "Dem. Rep. Congo",
        "Congo, DR": "Dem. Rep. Congo",
        "Zaire": "Dem. Rep. Congo",
        "Congo": "Congo",
        "Republic of the Congo": "Congo",

        // Myanmar
        "Myanmar (Burma)": "Myanmar",
        "Burma": "Myanmar",

        // Zimbabwe
        "Zimbabwe (Rhodesia)": "Zimbabwe",
        "Rhodesia": "Zimbabwe",

        // Yemen
        "Yemen (North Yemen)": "Yemen",
        "North Yemen": "Yemen",
        "South Yemen": "Yemen",

        // Russia/Soviet Union
        "Russia (Soviet Union)": "Russia",
        "Soviet Union": "Russia",
        "USSR": "Russia",

        // === YUGOSLAVIA SUCCESSOR STATES ===
        "Serbia (Yugoslavia)": "Serbia",
        "Yugoslavia": "Serbia",
        "Serbia and Montenegro": "Serbia",
        "Federal Republic of Yugoslavia": "Serbia",

        "Bosnia-Herzegovina": "Bosnia and Herz.",
        "Bosnia and Herzegovina": "Bosnia and Herz.",
        "Bosnia": "Bosnia and Herz.",

        "Montenegro": "Montenegro",

        "Macedonia": "North Macedonia",
        "FYROM": "North Macedonia",
        "Former Yugoslav Republic of Macedonia": "North Macedonia",

        "Croatia": "Croatia",
        "Slovenia": "Slovenia",

        // === ASIAN COUNTRIES ===
        "Laos": "Lao PDR",
        "Vietnam": "Vietnam",
        "Viet Nam": "Vietnam",

        "Timor-Leste (East Timor)": "Timor-Leste",
        "East Timor": "Timor-Leste",

        "North Korea": "Dem. Rep. Korea",
        "South Korea": "Korea",
        "Republic of Korea": "Korea",

        // === AFRICAN COUNTRIES ===
        "Libya": "Libya",
        "Egypt": "Egypt",
        "Tunisia": "Tunisia",
        "Algeria": "Algeria",
        "Morocco": "Morocco",

        "Mauritania": "Mauritania",
        "Senegal": "Senegal",
        "Gambia": "Gambia",
        "Guinea-Bissau": "Guinea-Bissau",
        "Guinea": "Guinea",
        "Sierra Leone": "Sierra Leone",
        "Liberia": "Liberia",
        "Ivory Coast": "Côte d'Ivoire",
        "Equatorial Guinea": "Eq. Guinea",
        "Gabon": "Gabon",

        "Sudan": "Sudan",
        "South Sudan": "S. Sudan",
        "Eritrea": "Eritrea",
        "Ethiopia": "Ethiopia",
        "Djibouti": "Djibouti",
        "Somalia": "Somalia",
        "Kenya": "Kenya",
        "Uganda": "Uganda",
        "Rwanda": "Rwanda",
        "Burundi": "Burundi",
        "Tanzania": "Tanzania",

        "Angola": "Angola",
        "Zambia": "Zambia",
        "Malawi": "Malawi",
        "Mozambique": "Mozambique",
        "Zimbabwe": "Zimbabwe",
        "Botswana": "Botswana",
        "Namibia": "Namibia",
        "South Africa": "South Africa",
        "Lesotho": "Lesotho",
        "Eswatini": "eSwatini",
        "Swaziland": "eSwatini",
        "Kingdom of eSwatini (Swaziland)": "eSwatini",

        // === EUROPEAN COUNTRIES ===
        "Czech Republic": "Czechia",
        "Czechia": "Czechia",

        "Belarus": "Belarus",
        "Byelarus": "Belarus",
        "Belorussia": "Belarus",

        "Moldova": "Moldova",
        "Moldavia": "Moldova",

        // === AMERICAS ===
        "United States": "United States of America",
        "USA": "United States of America",
        "US": "United States of America",
        "U.S.A.": "United States of America",

        "Dominican Republic": "Dominican Rep.",

        // === MIDDLE EAST ===
        "Palestine": "Palestine",
        "West Bank": "Palestine",
        "Gaza": "Palestine",

        // === ADDITIONAL MAPPINGS ===
        "United Kingdom": "United Kingdom",
        "UK": "United Kingdom",
        "Great Britain": "United Kingdom",

        "Bahrain": "Bahrain",
        "Comoros": "Comoros",
        "Madagascar": "Madagascar",
        "Madagascar (Malagasy)": "Madagascar",
        "Malagasy": "Madagascar",
        "North Macedonia": "North Macedonia",
        "Solomon Islands": "Solomon Is."
    };

    if (manualMapping[countryName]) {
        countryFeature = allCountryFeatures.find(c => c.properties.name === manualMapping[countryName]);
        if (countryFeature) return countryFeature;
    }

    // 4. Last resort: fuzzy matching
    countryFeature = allCountryFeatures.find(c => {
        const mapName = c.properties.name;
        if (mapName.includes(countryName) || countryName.includes(mapName)) {
            if (Math.abs(mapName.length - countryName.length) > 10) return false;
            return true;
        }
        return false;
    });

    return countryFeature;
}

function handleCountryClick(event, d) {
    event.stopPropagation();

    const mapCountryName = d.properties.name;

    // Reverse manual mapping: map feature name -> CSV country name
    const reverseMapping = {
        "Dem. Rep. Congo": "DR Congo (Zaire)",
        "Congo": "Congo",
        "S. Sudan": "South Sudan",
        "Central African Rep.": "Central African Republic",
        "Eq. Guinea": "Equatorial Guinea",
        "eSwatini": "Kingdom of eSwatini (Swaziland)",
        "Côte d'Ivoire": "Ivory Coast",
        "Lao PDR": "Laos",
        "Timor-Leste": "Timor-Leste (East Timor)",
        "Dem. Rep. Korea": "North Korea",
        "Korea": "South Korea",
        "Bosnia and Herz.": "Bosnia-Herzegovina",
        "North Macedonia": "Macedonia",
        "Czechia": "Czech Republic",
        "United States of America": "United States",
        "Dominican Rep.": "Dominican Republic",
        "Solomon Is.": "Solomon Islands",
        "Myanmar": "Myanmar (Burma)"
    };

    // Try to find the CSV name using reverse mapping
    const csvCountryName = reverseMapping[mapCountryName] || mapCountryName;

    // Try exact match with CSV name
    let countryConflictData = processedData.find(c => c.name === csvCountryName);

    // If no exact match, try fuzzy matching
    if (!countryConflictData) {
        // Trypartial matching
        countryConflictData = processedData.find(c =>
            c.name.includes(csvCountryName) || csvCountryName.includes(c.name)
        );

        // Try matching without common suffixes
        if (!countryConflictData) {
            const simplifiedMapName = csvCountryName
                .replace(/ \(.*\)/, '') // Remove parentheses
                .replace(/^The /, '') // Remove "The" prefix
                .replace(/ of America$/, ''); // Remove "of America" suffix

            countryConflictData = processedData.find(c => {
                const simplifiedDataName = c.name
                    .replace(/ \(.*\)/, '')
                    .replace(/^The /, '')
                    .replace(/ of America$/, '');
                return simplifiedDataName === simplifiedMapName;
            });
        }
    }

    if (!countryConflictData) {

        return;
    }

    enterCountryView(d, countryConflictData.name, countryConflictData);
}

function handleBubbleClick(event, d) {
    event.stopPropagation();

    const countryName = d.name;

    // 1. Try exact match first
    let countryFeature = mapGroup.selectAll(".country")
        .data()
        .find(c => c.properties.name === countryName);

    // 2. If no exact match, try normalized match
    if (!countryFeature) {
        const normalize = (str) => str.toLowerCase()
            .replace(/\bthe\b/g, '')
            .replace(/\brepublic of\b/g, '')
            .replace(/\bdemocratic republic of\b/g, '')
            .replace(/\bkingdom of\b/g, '')
            .replace(/\./g, '')
            .replace(/\s+/g, ' ')
            .trim();

        const normalizedTarget = normalize(countryName);

        countryFeature = mapGroup.selectAll(".country")
            .data()
            .find(c => normalize(c.properties.name) === normalizedTarget);
    }

    // 3. Check manual mapping FIRST (before fuzzy matching)
    // This prevents "DR Congo (Zaire)" from matching "Congo" in fuzzy search
    if (!countryFeature) {
        const manualMapping = {
            // === HISTORICAL/POLITICAL NAME CHANGES ===

            // Cambodia
            "Cambodia (Kampuchea)": "Cambodia",
            "Kampuchea": "Cambodia",

            // Congo variations - MUST come before fuzzy matching
            "DR Congo (Zaire)": "Dem. Rep. Congo",
            "DR Congo": "Dem. Rep. Congo",
            "Democratic Republic of the Congo": "Dem. Rep. Congo",
            "Congo, DR": "Dem. Rep. Congo",
            "Zaire": "Dem. Rep. Congo",
            "Congo": "Congo",  // Republic of Congo
            "Republic of the Congo": "Congo",

            // Myanmar
            "Myanmar (Burma)": "Myanmar",
            "Burma": "Myanmar",

            // Zimbabwe
            "Zimbabwe (Rhodesia)": "Zimbabwe",
            "Rhodesia": "Zimbabwe",

            // Yemen
            "Yemen (North Yemen)": "Yemen",
            "North Yemen": "Yemen",
            "South Yemen": "Yemen",

            // Russia/Soviet Union
            "Russia (Soviet Union)": "Russia",
            "Soviet Union": "Russia",
            "USSR": "Russia",

            // === YUGOSLAVIA SUCCESSOR STATES ===

            // Serbia
            "Serbia (Yugoslavia)": "Serbia",
            "Yugoslavia": "Serbia",
            "Serbia and Montenegro": "Serbia",
            "Federal Republic of Yugoslavia": "Serbia",

            // Bosnia
            "Bosnia-Herzegovina": "Bosnia and Herz.",
            "Bosnia and Herzegovina": "Bosnia and Herz.",
            "Bosnia": "Bosnia and Herz.",

            // Montenegro
            "Montenegro": "Montenegro",

            // Macedonia
            "Macedonia": "North Macedonia",
            "FYROM": "North Macedonia",
            "Former Yugoslav Republic of Macedonia": "North Macedonia",

            // Croatia
            "Croatia": "Croatia",

            // Slovenia
            "Slovenia": "Slovenia",

            // === ASIAN COUNTRIES ===

            // Laos
            "Laos": "Lao PDR",

            // Vietnam
            "Vietnam": "Vietnam",
            "Viet Nam": "Vietnam",

            // Timor
            "Timor-Leste (East Timor)": "Timor-Leste",
            "East Timor": "Timor-Leste",

            // Korea
            "North Korea": "Dem. Rep. Korea",
            "South Korea": "Korea",
            "Republic of Korea": "Korea",

            // === AFRICAN COUNTRIES ===

            // North Africa
            "Libya": "Libya",
            "Egypt": "Egypt",
            "Tunisia": "Tunisia",
            "Algeria": "Algeria",
            "Morocco": "Morocco",

            // West Africa
            "Mauritania": "Mauritania",
            "Senegal": "Senegal",
            "Gambia": "Gambia",
            "Guinea-Bissau": "Guinea-Bissau",
            "Guinea": "Guinea",
            "Sierra Leone": "Sierra Leone",
            "Liberia": "Liberia",
            "Ivory Coast": "Côte d'Ivoire",
            "Mali": "Mali",
            "Burkina Faso": "Burkina Faso",
            "Ghana": "Ghana",
            "Togo": "Togo",
            "Benin": "Benin",
            "Niger": "Niger",
            "Nigeria": "Nigeria",

            // Central Africa
            "Chad": "Chad",
            "Cameroon": "Cameroon",
            "Central African Republic": "Central African Rep.",
            "Equatorial Guinea": "Eq. Guinea",
            "Gabon": "Gabon",
            "Congo": "Congo",
            "Republic of the Congo": "Congo",
            "DR Congo (Zaire)": "Dem. Rep. Congo",
            "DR Congo": "Dem. Rep. Congo",
            "Democratic Republic of the Congo": "Dem. Rep. Congo",

            // East Africa
            "Sudan": "Sudan",
            "South Sudan": "S. Sudan",
            "Eritrea": "Eritrea",
            "Ethiopia": "Ethiopia",
            "Djibouti": "Djibouti",
            "Somalia": "Somalia",
            "Kenya": "Kenya",
            "Uganda": "Uganda",
            "Rwanda": "Rwanda",
            "Burundi": "Burundi",
            "Tanzania": "Tanzania",

            // Southern Africa
            "Angola": "Angola",
            "Zambia": "Zambia",
            "Malawi": "Malawi",
            "Mozambique": "Mozambique",
            "Zimbabwe": "Zimbabwe",
            "Botswana": "Botswana",
            "Namibia": "Namibia",
            "South Africa": "South Africa",
            "Lesotho": "Lesotho",
            "Eswatini": "eSwatini",
            "Swaziland": "eSwatini",
            "Kingdom of eSwatini (Swaziland)": "eSwatini",

            // === EUROPEAN COUNTRIES ===

            // Czech Republic
            "Czech Republic": "Czechia",
            "Czechia": "Czechia",

            // Belarus
            "Belarus": "Belarus",
            "Byelarus": "Belarus",
            "Belorussia": "Belarus",

            // Moldova
            "Moldova": "Moldova",
            "Moldavia": "Moldova",

            // === AMERICAS ===

            // United States
            "United States": "United States of America",
            "USA": "United States of America",
            "US": "United States of America",
            "U.S.A.": "United States of America",

            // Dominican Republic
            "Dominican Republic": "Dominican Rep.",

            // === MIDDLE EAST ===

            // Palestine
            "Palestine": "Palestine",
            "West Bank": "Palestine",
            "Gaza": "Palestine",

            // === ADDITIONAL MAPPINGS ===

            // United Kingdom
            "United Kingdom": "United Kingdom",
            "UK": "United Kingdom",
            "Great Britain": "United Kingdom",

            // === MISSING COUNTRIES FIX ===

            // Bahrain
            "Bahrain": "Bahrain",

            // Comoros
            "Comoros": "Comoros",

            // Kingdom of eSwatini
            "Kingdom of eSwatini (Swaziland)": "eSwatini",

            // Madagascar
            "Madagascar": "Madagascar",
            "Madagascar (Malagasy)": "Madagascar",
            "Malagasy": "Madagascar",

            // North Macedonia (explicit)
            "North Macedonia": "North Macedonia",

            // Solomon Islands
            "Solomon Islands": "Solomon Is."
        };

        const allCountryFeatures = mapGroup.selectAll(".country").data();
        if (manualMapping[countryName]) {
            countryFeature = allCountryFeatures.find(c => c.properties.name === manualMapping[countryName]);
        }
    }

    // 4. If still no match, try careful fuzzy matching
    if (!countryFeature) {
        const allCountryFeatures = mapGroup.selectAll(".country").data();

        // Try partial matching but be careful about substrings (e.g. "Niger" vs "Nigeria")
        countryFeature = allCountryFeatures.find(c => {
            const mapName = c.properties.name;
            // Check if one contains the other
            if (mapName.includes(countryName) || countryName.includes(mapName)) {
                // Verify it's not a completely different country with a similar name
                // e.g. Don't match "Niger" to "Nigeria" if we are looking for "Niger"
                // This is a heuristic; exact matches should have been caught above.

                // If the length difference is large, it might be a wrong match (e.g. "Sudan" vs "South Sudan")
                // unless it's a known abbreviation.
                if (Math.abs(mapName.length - countryName.length) > 10) return false;

                return true;
            }
            return false;
        });
    }

    if (countryFeature) {
        enterCountryView(countryFeature, countryName, d);
    } else {
        console.warn(`No map feature found for country bubble: "${countryName}". Map countries:`,
            mapGroup.selectAll(".country").data().map(c => c.properties.name).sort());
    }
}

function enterCountryView(countryFeature, countryName, countryConflictData, factionFilter = null) {
    // Store previous mode to return to it later
    if (viewState.mode === 'region') {
        viewState.previousMode = 'region';
        viewState.previousRegion = viewState.selectedRegion;
    } else {
        viewState.previousMode = 'world';
        viewState.previousRegion = null;
    }

    viewState.mode = 'country';
    viewState.selectedCountryName = countryName;
    viewState.selectedCountryData = countryConflictData;
    viewState.selectedConflictType = null;
    viewState.selectedFaction = factionFilter; // Store faction filter
    viewState.selectedEvent = null; // Clear any previous event selection

    // Remove any existing capital markers immediately
    bubblesGroup.selectAll(".capital-marker").remove();

    mapGroup.select(".sphere").style("opacity", 0).style("display", "none");
    mapGroup.select(".graticule").style("opacity", 0).style("display", "none");

    // Get neighboring countries
    const neighbors = getNeighboringCountries(countryName);

    // Show selected country and neighbors, keep all visible but dimmed
    mapGroup.selectAll(".country")
        .style("display", "block") // Ensure ALL countries remain visible
        .transition()
        .duration(500)
        .style("opacity", country => {
            const name = country.properties.name;
            if (name === countryName) return 1; // Selected country: full opacity
            if (neighbors.includes(name)) return 0.5; // Neighbors: medium opacity
            return 0.15; // Others: very dim but still visible
        })
        .style("pointer-events", country => {
            const name = country.properties.name;
            // Only selected country and neighbors are clickable
            return (name === countryName || neighbors.includes(name)) ? "auto" : "none";
        });

    zoomToCountry(countryFeature);

    bubblesGroup.selectAll(".conflict-bubble").remove();

    setTimeout(() => {
        drawIndividualEventBubbles();
    }, 600);

    updateLeftPanel();

    d3.select("#charts-panel").style("display", "flex");
    d3.select("#charts-title").text("Statistics & Rankings");

    // Update subtitle to show faction filter if active
    const subtitle = factionFilter
        ? `Filtered by faction: ${factionFilter}`
        : "Comprehensive Data";
    d3.select("#charts-subtitle").text(subtitle);

    d3.select("#reset-zoom").style("display", "block");

    setTimeout(() => {
        updateAllCharts();
    }, 800);

    // DISABLED: Draw Capital Marker (user requested removal)
    // drawCapitalMarker(countryName);
}

// ============================================================================
// FACTION VIEW MODE
// ============================================================================

function enterFactionView(factionId, factionNodeData) {


    // Store previous mode
    if (viewState.mode === 'region') {
        viewState.previousMode = 'region';
        viewState.previousRegion = viewState.selectedRegion;
    } else {
        viewState.previousMode = 'world';
        viewState.previousRegion = null;
    }

    viewState.mode = 'faction';
    viewState.selectedFactionName = factionId;
    viewState.selectedFaction = factionId; // For filter compatibility

    // Step 1: Collect all events involving this faction using optimized index lookup
    const currentYear = +document.getElementById('year-slider').value;
    const filterOptions = { year: currentYear };
    if (viewState.selectedViolenceType) {
        filterOptions.violenceType = viewState.selectedViolenceType;
    }

    let allFactionEvents = dataFilterManager.getFactionEvents(factionId, filterOptions);

    // Store for chart access
    viewState.selectedFactionData = allFactionEvents;

    // Step 2: Determine unique countries
    const countries = [...new Set(allFactionEvents.map(e => e.country))].sort();



    // Step 3: Clear existing bubbles
    bubblesGroup.selectAll("*").remove();

    // Step 4: Intelligent zoom logic
    if (countries.length === 1) {
        // Single country: zoom to that country
        const countryFeature = findCountryFeature(countries[0]);
        if (countryFeature) {
            zoomToCountry(countryFeature);
        }
    } else {
        // Multiple countries: check geographic spread
        const bounds = calculateEventsBounds(allFactionEvents);
        if (bounds && isRegionalCluster(bounds)) {
            // Regional cluster: zoom to bounds
            zoomToBounds(bounds);
        } else {
            // Global dispersion: keep world view
            resetMapZoom();
        }
    }

    // Step 5: Draw faction bubbles
    drawFactionBubbles(allFactionEvents);

    // Step 6: Update panels and charts
    updateFactionPanel(factionId, allFactionEvents, countries, factionNodeData);

    // Step 7: Show right panel with charts
    d3.select("#charts-panel").style("display", "flex");
    d3.select("#charts-title").text("Faction Statistics");
    d3.select("#charts-subtitle").text(factionId);

    d3.select("#reset-zoom").style("display", "block");

    // Draw charts after a short delay
    setTimeout(() => {
        updateAllCharts();
    }, 800);
}

function drawFactionBubbles(events) {
    const eventsWithCoords = events.filter(e =>
        e.latitude != null && e.longitude != null
    );

    if (eventsWithCoords.length === 0) return;

    // Scale bubbles by casualties
    const maxCasualties = d3.max(eventsWithCoords, e => e.best) || 1;
    const zoomFactor = viewState.zoomScale || 1;
    const baseRange = [3 / zoomFactor, 20 / zoomFactor];

    const radiusScale = d3.scaleSqrt()
        .domain([0, maxCasualties])
        .range(baseRange);

    // Enter new bubbles
    const bubbles = bubblesGroup.selectAll(".event-bubble")
        .data(eventsWithCoords, d => d.id || `${d.country}-${d.year}-${d.latitude}-${d.longitude}`)
        .join(
            enter => enter.append("circle")
                .attr("class", "event-bubble")
                .attr("cx", d => projection([d.longitude, d.latitude])[0])
                .attr("cy", d => projection([d.longitude, d.latitude])[1])
                .attr("r", 0)
                .style("fill", d => TYPE_COLORS[d.type_of_violence_name])
                .style("opacity", 0)
                .style("cursor", "pointer")
                .on("click", (event, d) => {
                    event.stopPropagation();
                    selectEvent(d);
                }),
            update => update,
            exit => exit.remove()
        );

    // Animate bubbles in
    bubbles.transition()
        .duration(800)
        .attr("r", d => radiusScale(d.best))
        .style("opacity", 0.7);
}

function updateFactionPanel(factionId, events, countries, factionNodeData) {
    const leftPanel = d3.select("#left-panel");

    // Clear existing content
    leftPanel.selectAll(".country-info-section, .stats-container").remove();
    leftPanel.select("#faction-info-panel").remove();

    // Hide legend sections during faction view
    d3.select(".legend-section").style("display", "none");
    d3.select(".violence-filter-section").style("display", "none");

    const currentYear = +document.getElementById('year-slider').value;
    const currentEvents = events.filter(e => e.year <= currentYear);
    const casualties = d3.sum(currentEvents, e => e.best);

    // Determine region from events or nodeData
    const region = factionNodeData?.region ||
        (currentEvents.length > 0 ? currentEvents[0].region : "Multiple Regions");

    // Create faction info panel (using same styling as graph.js)
    const factionPanel = leftPanel.insert("div", ":first-child")
        .attr("id", "faction-info-panel")
        .style("padding", "1.5rem")
        .style("background", "linear-gradient(135deg, #f8fafc 0%, #e0e7ff 100%)")
        .style("border-radius", "8px")
        .style("margin-bottom", "1rem")
        .style("box-shadow", "0 2px 8px rgba(0,0,0,0.1)");

    // Title
    const countryFilter = viewState.selectedCountryInFaction;
    const panelTitle = countryFilter
        ? `Faction Details in ${countryFilter}`
        : "Faction Details";

    factionPanel.append("h3")
        .style("margin", "0 0 1rem 0")
        .style("font-size", "1.2rem")
        .style("color", "#1e293b")
        .style("border-bottom", "2px solid #cbd5e1")
        .style("padding-bottom", "0.5rem")
        .text(panelTitle);

    // Faction name box
    factionPanel.append("div")
        .style("margin-bottom", "1rem")
        .style("padding", "0.75rem")
        .style("background", "white")
        .style("border-radius", "6px")
        .style("border-left", `4px solid ${REGION_COLORS[region] || "#64748b"}`)
        .html(`
            <div style="font-weight: 700; font-size: 1rem; color: #1e293b; margin-bottom: 0.25rem;">${factionId}</div>
            <div style="font-size: 0.85rem; color: #64748b;">${countries.length > 1 ? 'Multiple Countries' : countries[0] || 'Unknown'}</div>
        `);

    // Stats grid (2x2)
    const statsGrid = factionPanel.append("div")
        .style("display", "grid")
        .style("grid-template-columns", "1fr 1fr")
        .style("gap", "0.75rem")
        .style("margin-bottom", "1rem");

    // Region stat
    const regionStat = statsGrid.append("div")
        .style("background", "white")
        .style("padding", "0.75rem")
        .style("border-radius", "6px")
        .style("box-shadow", "0 1px 3px rgba(0,0,0,0.05)");
    regionStat.append("div")
        .style("font-size", "0.75rem")
        .style("color", "#94a3b8")
        .style("margin-bottom", "0.25rem")
        .text("Region");
    regionStat.append("div")
        .style("font-weight", "600")
        .style("color", REGION_COLORS[region] || "#64748b")
        .text(region);

    // Events stat
    const eventsStat = statsGrid.append("div")
        .style("background", "white")
        .style("padding", "0.75rem")
        .style("border-radius", "6px")
        .style("box-shadow", "0 1px 3px rgba(0,0,0,0.05)");
    eventsStat.append("div")
        .style("font-size", "0.75rem")
        .style("color", "#94a3b8")
        .style("margin-bottom", "0.25rem")
        .text("Events");
    eventsStat.append("div")
        .style("font-weight", "700")
        .style("color", "#3b82f6")
        .text(d3.format(",d")(currentEvents.length));

    // Casualties stat
    const casualtiesStat = statsGrid.append("div")
        .style("background", "white")
        .style("padding", "0.75rem")
        .style("border-radius", "6px")
        .style("box-shadow", "0 1px 3px rgba(0,0,0,0.05)");
    casualtiesStat.append("div")
        .style("font-size", "0.75rem")
        .style("color", "#94a3b8")
        .style("margin-bottom", "0.25rem")
        .text("Casualties");
    casualtiesStat.append("div")
        .style("font-weight", "700")
        .style("color", "#ef4444")
        .text(d3.format(",d")(casualties));

    // Connections stat (only if factionNodeData available)
    const connectionsStat = statsGrid.append("div")
        .style("background", "white")
        .style("padding", "0.75rem")
        .style("border-radius", "6px")
        .style("box-shadow", "0 1px 3px rgba(0,0,0,0.05)");
    connectionsStat.append("div")
        .style("font-size", "0.75rem")
        .style("color", "#94a3b8")
        .style("margin-bottom", "0.25rem")
        .text("Connections");
    connectionsStat.append("div")
        .style("font-weight", "700")
        .style("color", "#8b5cf6")
        .text(factionNodeData?.connections || countries.length);

    // Activity Period
    if (currentEvents.length > 0) {
        const years = currentEvents.map(e => e.year);
        const minYear = Math.min(...years);
        const maxYear = Math.max(...years);

        const periodStat = statsGrid.append("div")
            .style("background", "white")
            .style("padding", "0.75rem")
            .style("border-radius", "6px")
            .style("box-shadow", "0 1px 3px rgba(0,0,0,0.05)")
            .style("grid-column", "1 / -1");

        periodStat.append("div")
            .style("font-size", "0.75rem")
            .style("color", "#94a3b8")
            .style("margin-bottom", "0.25rem")
            .text("Activity Period");

        periodStat.append("div")
            .style("font-weight", "600")
            .style("color", "#64748b")
            .text(`${minYear} - ${maxYear} (${maxYear - minYear + 1} years)`);
    }

    // Countries Involved with casualties
    if (!countryFilter && countries.length >= 1) {
        factionPanel.append("h4")
            .style("margin", "1rem 0 0.5rem 0")
            .style("font-size", "0.9rem")
            .style("color", "#475569")
            .text(`Countries Involved (${countries.length})`);

        const countriesContainer = factionPanel.append("div")
            .style("background", "white")
            .style("border-radius", "6px")
            .style("padding", "0.75rem")
            .style("margin-bottom", "1rem")
            .style("max-height", "120px")
            .style("overflow-y", "auto");

        const countryStats = countries.map(country => ({
            name: country,
            events: currentEvents.filter(e => e.country === country).length,
            casualties: d3.sum(currentEvents.filter(e => e.country === country), e => e.best)
        })).sort((a, b) => b.casualties - a.casualties);

        countryStats.forEach(country => {
            countriesContainer.append("div")
                .style("display", "flex")
                .style("justify-content", "space-between")
                .style("padding", "0.25rem 0")
                .style("font-size", "0.75rem")
                .style("border-bottom", "1px solid #f1f5f9")
                .html(`
                    <span style="color: #475569;">${country.name}</span>
                    <span style="color: #ef4444; font-weight: 600;">${d3.format(",d")(country.casualties)}</span>
                `);
        });
    }

    // Violence Type Distribution
    if (currentEvents.length > 0) {
        const violenceTypes = d3.rollup(
            currentEvents,
            v => ({ count: v.length, casualties: d3.sum(v, e => e.best) }),
            d => d.type_of_violence_name
        );

        factionPanel.append("h4")
            .style("margin", "1rem 0 0.5rem 0")
            .style("font-size", "0.9rem")
            .style("color", "#475569")
            .text("Violence Type Distribution");

        const violenceContainer = factionPanel.append("div")
            .style("background", "white")
            .style("border-radius", "6px")
            .style("padding", "0.75rem")
            .style("margin-bottom", "1rem");

        const sortedTypes = Array.from(violenceTypes.entries())
            .sort((a, b) => b[1].casualties - a[1].casualties);

        const maxCasualties = d3.max(sortedTypes, d => d[1].casualties);

        sortedTypes.forEach(([type, data]) => {
            const percentage = (data.casualties / maxCasualties) * 100;

            const typeRow = violenceContainer.append("div")
                .style("margin-bottom", "0.5rem");

            typeRow.append("div")
                .style("display", "flex")
                .style("justify-content", "space-between")
                .style("font-size", "0.75rem")
                .style("margin-bottom", "0.25rem")
                .html(`
                    <span style="color: #475569; font-weight: 500;">${type}</span>
                    <span style="color: #ef4444; font-weight: 600;">${d3.format(",d")(data.casualties)}</span>
                `);

            typeRow.append("div")
                .style("height", "6px")
                .style("background", "#e2e8f0")
                .style("border-radius", "3px")
                .style("overflow", "hidden")
                .append("div")
                .style("width", `${percentage}%`)
                .style("height", "100%")
                .style("background", TYPE_COLORS[type] || "#64748b")
                .style("transition", "width 0.3s ease");
        });
    }
}


// ============================================================================
// FACTION DETAIL VIEW (called from Graph View)
// ============================================================================

/**
 * Enter faction detail view from graph view.
 * This is a wrapper for enterFactionView to provide consistent naming
 * from the graph view context.
 */
function enterFactionDetailView(factionId, factionNodeData) {
    enterFactionView(factionId, factionNodeData);
}

// ============================================================================
// FACTION CHART RENDERING
// ============================================================================

/**
 * Update all charts for faction view with comprehensive visualizations
 * UNIFIED: Uses ChartRenderer for consistent UI across all views
 */
function updateFactionCharts() {
    const events = viewState.selectedFactionData || [];

    if (events.length === 0) {
        console.warn("No faction events data available for charts");
        return;
    }

    // Aggregate data for charts using DataManager
    const chartData = dataManager.aggregateDataForCharts(events);

    // Use ChartRenderer for all charts - SAME as Country View!
    ChartRenderer.drawTimelineChart(chartData.byYear, '#chart-timeline');
    ChartRenderer.drawViolenceTypeChart(chartData.byViolenceType, '#chart-violence-type');
    ChartRenderer.drawYearMonthHeatmap(chartData.byMonth, '#chart-victims');
    ChartRenderer.renderTopEventsList(chartData.topEvents, '#chart-top-events', {
        onEventClick: (event) => selectEvent(event)
    });
}

/**
 * Render timeline chart showing casualties over time
 */
function renderFactionTimelineChart(events) {
    const container = d3.select("#chart-timeline");
    const width = 400;
    const height = 180;
    const margin = { top: 20, right: 20, bottom: 30, left: 50 };

    const svg = container
        .attr("width", width)
        .attr("height", height);

    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Aggregate by year
    const yearData = d3.rollup(
        events,
        v => d3.sum(v, d => d.best),
        d => d.year
    );

    const data = Array.from(yearData, ([year, casualties]) => ({ year, casualties }))
        .sort((a, b) => a.year - b.year);

    // Scales
    const x = d3.scaleLinear()
        .domain(d3.extent(data, d => d.year))
        .range([0, chartWidth]);

    const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.casualties)])
        .nice()
        .range([chartHeight, 0]);

    // Line
    const line = d3.line()
        .x(d => x(d.year))
        .y(d => y(d.casualties))
        .curve(d3.curveMonotoneX);

    // Area
    const area = d3.area()
        .x(d => x(d.year))
        .y0(chartHeight)
        .y1(d => y(d.casualties))
        .curve(d3.curveMonotoneX);

    // Draw area
    g.append("path")
        .datum(data)
        .attr("fill", "rgba(239, 68, 68, 0.2)")
        .attr("d", area);

    // Draw line
    g.append("path")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", "#ef4444")
        .attr("stroke-width", 2)
        .attr("d", line);

    // Axes
    g.append("g")
        .attr("transform", `translate(0,${chartHeight})`)
        .call(d3.axisBottom(x).tickFormat(d3.format("d")).ticks(5))
        .style("font-size", "10px");

    g.append("g")
        .call(d3.axisLeft(y).ticks(5))
        .style("font-size", "10px");
}

/**
 * Render violence type distribution pie chart
 */
function renderFactionViolenceTypeChart(events) {
    const container = d3.select("#chart-violence-type");
    const width = 400;
    const height = 180;
    const radius = Math.min(width, height) / 2 - 10;

    container
        .attr("width", width)
        .attr("height", height);

    const g = container.append("g")
        .attr("transform", `translate(${width / 2},${height / 2})`);

    const data = d3.rollup(
        events,
        v => v.length,
        d => d.type_of_violence_name
    );

    const pie = d3.pie()
        .value(d => d[1])
        .sort(null);

    const arc = d3.arc()
        .innerRadius(radius * 0.5)
        .outerRadius(radius);

    const arcs = g.selectAll(".arc")
        .data(pie(Array.from(data)))
        .join("g")
        .attr("class", "arc");

    arcs.append("path")
        .attr("d", arc)
        .attr("fill", d => TYPE_COLORS[d.data[0]] || "#64748b")
        .attr("stroke", "white")
        .attr("stroke-width", 2);

    arcs.append("text")
        .attr("transform", d => `translate(${arc.centroid(d)})`)
        .attr("text-anchor", "middle")
        .style("font-size", "10px")
        .style("fill", "white")
        .style("font-weight", "600")
        .text(d => d.data[1] > 5 ? d.data[1] : "");
}

/**
 * Render victim composition pie chart
 */
function renderFactionVictimChart(events) {
    const container = d3.select("#chart-victims");
    const width = 400;
    const height = 180;
    const radius = Math.min(width, height) / 2 - 10;

    container
        .attr("width", width)
        .attr("height", height);

    const g = container.append("g")
        .attr("transform", `translate(${width / 2},${height / 2})`);

    const civilianCasualties = d3.sum(events, e => (e.deaths_civilians || 0));
    const combatantCasualties = d3.sum(events, e => (e.deaths_a || 0) + (e.deaths_b || 0));
    const unknownCasualties = d3.sum(events, e => (e.deaths_unknown || 0));

    const data = [
        { label: "Civilians", value: civilianCasualties, color: "#ef4444" },
        { label: "Combatants", value: combatantCasualties, color: "#f59e0b" },
        { label: "Unknown", value: unknownCasualties, color: "#94a3b8" }
    ].filter(d => d.value > 0);

    const pie = d3.pie()
        .value(d => d.value)
        .sort(null);

    const arc = d3.arc()
        .innerRadius(radius * 0.5)
        .outerRadius(radius);

    const arcs = g.selectAll(".arc")
        .data(pie(data))
        .join("g")
        .attr("class", "arc");

    arcs.append("path")
        .attr("d", arc)
        .attr("fill", d => d.data.color)
        .attr("stroke", "white")
        .attr("stroke-width", 2);

    arcs.append("text")
        .attr("transform", d => `translate(${arc.centroid(d)})`)
        .attr("text-anchor", "middle")
        .style("font-size", "10px")
        .style("fill", "white")
        .style("font-weight", "600")
        .text(d => d.data.value > 50 ? d3.format(",")(d.data.value) : "");
}

/**
 * Render top events list
 */
function renderFactionTopEvents(events) {
    const container = d3.select("#chart-top-events");
    container.selectAll("*").remove();

    const topEvents = events
        .sort((a, b) => b.best - a.best)
        .slice(0, 10);

    topEvents.forEach((event, idx) => {
        const item = container.append("div")
            .attr("class", "event-item")
            .style("cursor", "pointer")
            .on("click", () => {
                selectEvent(event);
            });

        item.append("div")
            .attr("class", "event-item-title")
            .text(`${idx + 1}. ${event.country} - ${event.dyad_name || "Conflict"}`);

        item.append("div")
            .attr("class", "event-item-meta")
            .html(`
                ${event.date_start || event.year} • 
                <strong style="color: #ef4444;">${d3.format(",")(event.best)} casualties</strong> • 
                ${event.type_of_violence_name}
            `);
    });
}

function drawCapitalMarker(countryName) {
    const info = countryInfoMap.get(countryName);
    if (!info || !info.capitalCoords) return;

    const [lon, lat] = info.capitalCoords;
    const projected = projection([lon, lat]);

    if (!projected) return;

    // Calculate star size based on LARGEST EVENT BUBBLE in this country
    const zoomFactor = viewState.zoomScale || 1;
    let starSize = 10; // Default size in pixels

    if (viewState.selectedCountryData) {
        const currentYear = +document.getElementById('year-slider').value;

        // Get events for this country
        let events = viewState.selectedCountryData.eventsWithCoords.filter(e => e.year <= currentYear);

        if (events.length > 0) {
            // Find the largest individual event (not total casualties)
            const maxEventCasualties = d3.max(events, d => d.best);

            // Use the SAME scaling as individual event bubbles
            const baseRange = [3 / zoomFactor, 20 / zoomFactor];
            const radiusScale = d3.scaleSqrt()
                .domain([0, maxEventCasualties])
                .range(baseRange);

            // Calculate the radius of the largest event bubble
            const largestBubbleRadius = radiusScale(maxEventCasualties);

            // Make star smaller: 30% of largest bubble
            // Reduced size to not overwhelm small countries
            starSize = Math.max(5, Math.min(12, largestBubbleRadius * 0.3));
        }
    }

    const g = bubblesGroup.append("g")
        .attr("class", "capital-marker")
        .attr("data-country", countryName) // Store country name for updates
        .attr("transform", `translate(${projected[0]}, ${projected[1]})`)
        .style("opacity", 0)
        .style("cursor", "pointer");

    // Star Icon with dynamic size and tooltip
    g.append("text")
        .attr("class", "capital-star")
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .style("font-size", `${starSize}px`)
        .text("★")
        .append("title")
        .text(info.capital); // Tooltip shows capital name on hover

    g.transition().duration(800).style("opacity", 1);
}

// Update capital marker size on zoom
function updateCapitalMarkerSize() {
    const zoomFactor = viewState.zoomScale || 1;

    bubblesGroup.selectAll(".capital-marker")
        .each(function () {
            const marker = d3.select(this);
            const countryName = marker.attr("data-country");

            let starSize = 10; // Default size

            if (viewState.selectedCountryData && viewState.selectedCountryName === countryName) {
                const currentYear = +document.getElementById('year-slider').value;
                let events = viewState.selectedCountryData.eventsWithCoords.filter(e => e.year <= currentYear);

                if (events.length > 0) {
                    const maxEventCasualties = d3.max(events, d => d.best);
                    const baseRange = [3 / zoomFactor, 20 / zoomFactor];
                    const radiusScale = d3.scaleSqrt()
                        .domain([0, maxEventCasualties])
                        .range(baseRange);

                    const largestBubbleRadius = radiusScale(maxEventCasualties);
                    starSize = Math.max(5, Math.min(12, largestBubbleRadius * 0.3));
                }
            }

            marker.select(".capital-star")
                .transition()
                .duration(100)
                .style("font-size", `${starSize}px`);
        });
}

function zoomToCountry(countryFeature) {
    if (!countryFeature) return;

    const bounds = path.bounds(countryFeature);

    // Validate bounds to prevent errors
    if (!bounds || !bounds[0] || !bounds[1] ||
        !isFinite(bounds[0][0]) || !isFinite(bounds[0][1]) ||
        !isFinite(bounds[1][0]) || !isFinite(bounds[1][1])) {
        console.warn("Invalid bounds for country:", countryFeature.properties?.name);
        return;
    }

    const dx = bounds[1][0] - bounds[0][0];
    const dy = bounds[1][1] - bounds[0][1];
    const x = (bounds[0][0] + bounds[1][0]) / 2;
    const y = (bounds[0][1] + bounds[1][1]) / 2;

    // Prevent division by zero or infinite scale
    if (dx === 0 || dy === 0) return;

    const scale = Math.max(2, Math.min(300, 0.9 / Math.max(dx / mapWidth, dy / mapHeight)));

    viewState.zoomScale = scale;

    const translate = [mapWidth / 2 - scale * x, mapHeight / 2 - scale * y];

    svg.transition()
        .duration(750)
        .call(
            zoom.transform,
            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
        );
}

// ============================================================================
// FACTION VIEW ZOOM HELPERS
// ============================================================================

// Calculate geographic bounds of events
function calculateEventsBounds(events) {
    const coordEvents = events.filter(e => e.latitude != null && e.longitude != null);
    if (coordEvents.length === 0) return null;

    const lons = coordEvents.map(e => e.longitude);
    const lats = coordEvents.map(e => e.latitude);

    return {
        minLon: d3.min(lons),
        maxLon: d3.max(lons),
        minLat: d3.min(lats),
        maxLat: d3.max(lats)
    };
}

// Check if events form a regional cluster (not globally dispersed)
function isRegionalCluster(bounds) {
    if (!bounds) return false;

    const lonSpan = bounds.maxLon - bounds.minLon;
    const latSpan = bounds.maxLat - bounds.minLat;

    // If events span < 60 degrees lon/lat, consider it regional
    return lonSpan < 60 && latSpan < 60;
}

// Zoom to geographic bounds
function zoomToBounds(bounds) {
    if (!bounds) return;

    // Project bounds to screen coordinates
    const p1 = projection([bounds.minLon, bounds.minLat]);
    const p2 = projection([bounds.maxLon, bounds.maxLat]);

    if (!p1 || !p2) return;

    const dx = Math.abs(p2[0] - p1[0]);
    const dy = Math.abs(p2[1] - p1[1]);
    const cx = (p1[0] + p2[0]) / 2;
    const cy = (p1[1] + p2[1]) / 2;

    // Calculate appropriate zoom scale with padding
    const scale = Math.max(1.2, Math.min(8, 0.8 / Math.max(dx / mapWidth, dy / mapHeight)));
    const translate = [mapWidth / 2 - scale * cx, mapHeight / 2 - scale * cy];

    viewState.zoomScale = scale;

    svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
}

// Reset map zoom to world view
function resetMapZoom() {
    viewState.zoomScale = 1;

    svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity);
}


function exitCountryView() {
    // ========================================================================
    // COMPREHENSIVE CLEANUP - Ensure ALL bubble/marker types are removed
    // ========================================================================
    bubblesGroup.selectAll(".event-bubble").remove();
    bubblesGroup.selectAll(".capital-marker").remove();
    bubblesGroup.selectAll(".conflict-bubble").remove();
    bubblesGroup.selectAll("circle").remove(); // Remove any orphaned circles
    bubblesGroup.selectAll("*").remove(); // Complete cleanup of bubbles group

    // Check if we should return to region view
    if (viewState.previousMode === 'region' && viewState.previousRegion) {
        // Clean up country-specific charts
        d3.select("#chart-heatmap-container").remove();
        d3.select("#chart-victims").classed("h-320", false);

        // Restore region view
        toggleRegion(viewState.previousRegion);
        return;
    }

    // ========================================================================
    // RESET ALL VIEW STATE PROPERTIES - Return to pristine world view
    // ========================================================================
    viewState.mode = 'world';
    viewState.selectedCountryName = null;
    viewState.selectedCountryData = null;
    viewState.selectedConflictType = null;
    viewState.selectedEvent = null;
    viewState.selectedRegion = null; // Clear region filter
    viewState.selectedViolenceType = null; // Clear violence type filter
    viewState.selectedFaction = null; // Clear faction filter
    viewState.previousMode = null; // Clear previous mode tracking
    viewState.previousRegion = null; // Clear previous region tracking
    viewState.zoomScale = 1;

    // ========================================================================
    // RESET ZOOM TO IDENTITY - Return to default zoom level
    // ========================================================================
    svg.transition()
        .duration(500)
        .call(zoom.transform, d3.zoomIdentity);

    // ========================================================================
    // RESTORE SPHERE AND GRATICULE - Show global map elements
    // ========================================================================
    mapGroup.select(".sphere")
        .style("display", "block")
        .transition()
        .duration(300)
        .style("opacity", 1);

    mapGroup.select(".graticule")
        .style("display", "block")
        .transition()
        .duration(300)
        .style("opacity", 0.1); // FIXED: World view uses 0.1 opacity, not 1

    // ========================================================================
    // RESTORE ALL COUNTRIES - Full opacity and clickable
    // ========================================================================
    mapGroup.selectAll(".country")
        .style("display", "block")
        .style("pointer-events", "auto")
        .transition()
        .duration(300)
        .style("opacity", 1)
        .style("stroke-width", null) // Clear any custom stroke width
        .style("stroke", null); // Clear any custom stroke color

    // ========================================================================
    // RESET LEFT PANEL - Remove country-specific sections
    // ========================================================================
    resetLeftPanel();

    // ========================================================================
    // REMOVE ALL COUNTRY-SPECIFIC CHARTS AND ELEMENTS
    // ========================================================================
    d3.select("#chart-heatmap-container").remove();
    d3.select("#chart-victims").classed("h-320", false);
    d3.select("#country-info-section").remove();
    d3.select("#stats-overview-section").remove();
    d3.select("#country-name-section").remove();
    d3.select("#pie-chart-section").remove();

    // ========================================================================
    // SHOW TOP COUNTRIES PANEL - Restore world view right panel
    // ========================================================================
    d3.select("#charts-panel").style("display", "flex");
    d3.select("#charts-title").text("Top Countries");
    d3.select("#charts-subtitle").text("Comprehensive Statistics");

    // ========================================================================
    // HIDE BACK BUTTON - Only shown in country/region view
    // ========================================================================
    d3.select("#reset-zoom").style("display", "none");

    // ========================================================================
    // RESET LEGEND AND FILTERS - All regions/types active
    // ========================================================================
    d3.selectAll(".legend-item").classed("active", true).classed("selected", false);
    d3.selectAll("#violence-type-filter .legend-item").classed("selected", false);

    // ========================================================================
    // UPDATE STATS FOR WORLD VIEW - Calculate global statistics
    // ========================================================================
    updateStats();

    // ========================================================================
    // REDRAW WORLD BUBBLES - Show global conflict data
    // Use setTimeout to ensure ALL DOM cleanup is complete
    // ========================================================================
    setTimeout(() => {
        drawConflictBubbles();
        renderTopCountriesList();
    }, 150); // Slightly longer delay to ensure complete cleanup
}


// Back button handler - using unified navigation (setupBackButton handles this)

// ============================================================================
// LEFT PANEL UPDATES
// ============================================================================

function updateLeftPanel() {
    if (!viewState.selectedCountryData) return;

    const data = viewState.selectedCountryData;
    const currentYear = +document.getElementById('year-slider').value;
    let filteredEvents = data.events.filter(e => e.year <= currentYear);

    // Apply violence type filter if active
    if (viewState.selectedViolenceType) {
        filteredEvents = filteredEvents.filter(e => e.type_of_violence_name === viewState.selectedViolenceType);
    }

    // Apply faction filter if active
    if (viewState.selectedFaction) {
        filteredEvents = filteredEvents.filter(e => {
            const sideA = e.side_a || '';
            const sideB = e.side_b || '';
            return sideA.includes(viewState.selectedFaction) || sideB.includes(viewState.selectedFaction);
        });
    }

    const leftPanel = d3.select(".left-panel");

    // Hide default sections
    d3.select(".legend-section").style("display", "none");
    d3.select(".stats-container").style("display", "none");
    d3.select(".violence-filter-section").style("display", "none");

    // Remove previous country panel if any
    d3.select("#country-name-section").remove();
    d3.select("#country-info-section").remove();
    d3.select("#stats-overview-section").remove();
    d3.select("#country-panel-unified").remove();

    // Get connected factions (all factions active in this country)
    const factionCasualties = {};
    filteredEvents.forEach(event => {
        const sideA = event.side_a || '';
        const sideB = event.side_b || '';

        // Track side_a
        if (sideA) {
            if (!factionCasualties[sideA]) {
                factionCasualties[sideA] = { casualties: 0, events: 0 };
            }
            factionCasualties[sideA].casualties += event.deaths_a || 0;
            factionCasualties[sideA].events++;
        }

        // Track side_b
        if (sideB) {
            if (!factionCasualties[sideB]) {
                factionCasualties[sideB] = { casualties: 0, events: 0 };
            }
            factionCasualties[sideB].casualties += event.deaths_b || 0;
            factionCasualties[sideB].events++;
        }
    });

    const connectedFactions = Object.entries(factionCasualties)
        .map(([name, data]) => ({
            name,
            casualties: data.casualties,
            events: data.events,
            color: '#ef4444'
        }))
        .sort((a, b) => b.casualties - a.casualties)
        .slice(0, 15); // Top 15 factions

    // Create unified panel container
    const panelContainer = leftPanel.insert("div", ".reset-btn")
        .attr("id", "country-panel-unified");

    // Use shared renderEntityInfoPanel for unified UI (like faction view)
    renderEntityInfoPanel(panelContainer, {
        title: "Country Details",
        entityName: viewState.selectedCountryName,
        entitySubtext: data.region,
        entityColor: REGION_COLORS[data.region] || '#64748b',
        events: filteredEvents,
        country: viewState.selectedCountryName,
        region: data.region,
        connectedEntities: connectedFactions,
        connectedTitle: "Active Factions",
        showHeatmap: true,
        showViolenceBreakdown: true,
        onEntityClick: (faction) => {
            // Filter by clicked faction
            viewState.selectedFaction = faction.name;
            updateLeftPanel();
            drawIndividualEventBubbles();
            updateAllCharts();
        }
    });

    // Add faction filter reset button if filter is active
    if (viewState.selectedFaction) {
        const panel = panelContainer.select("div");
        panel.append("button")
            .style("width", "100%")
            .style("padding", "0.5rem 1rem")
            .style("margin-top", "1rem")
            .style("background", "#ef4444")
            .style("color", "white")
            .style("border", "none")
            .style("border-radius", "6px")
            .style("cursor", "pointer")
            .style("font-weight", "600")
            .style("font-size", "0.85rem")
            .text(`✕ Clear Faction Filter: ${viewState.selectedFaction}`)
            .on("click", () => {
                viewState.selectedFaction = null;
                updateLeftPanel();
                drawIndividualEventBubbles();
                updateAllCharts();
            });
    }
}

function drawCasualtyStackedBar(casualties, total) {
    const container = d3.select("#casualty-stacked-bar");
    container.html('');

    const width = container.node().getBoundingClientRect().width || 240;
    const height = 30;

    const svg = container.append("svg")
        .attr("width", width)
        .attr("height", height);

    const colors = {
        side_a: '#d62728',
        side_b: '#1f77b4',
        civilians: '#2ca02c',
        unknown: '#7f7f7f'
    };

    const labels = {
        side_a: 'Country',
        side_b: 'Opponent',
        civilians: 'Civilians',
        unknown: 'Unknown'
    };

    let x = 0;
    Object.entries(casualties).forEach(([key, value]) => {
        if (value > 0) {
            const barWidth = (value / total) * width;

            svg.append("rect")
                .attr("x", x)
                .attr("y", 0)
                .attr("width", barWidth)
                .attr("height", height)
                .attr("fill", colors[key])
                .attr("rx", 2)
                .append("title")
                .text(`${labels[key]}: ${d3.format(",d")(value)} (${d3.format(".1%")(value / total)})`);

            x += barWidth;
        }
    });

    // Add legend below
    const legend = container.append("div")
        .style("display", "flex")
        .style("gap", "8px")
        .style("margin-top", "5px")
        .style("flex-wrap", "wrap");

    Object.entries(casualties).forEach(([key, value]) => {
        if (value > 0) {
            const item = legend.append("div")
                .style("display", "flex")
                .style("align-items", "center")
                .style("gap", "4px")
                .style("font-size", "0.7rem");

            item.append("div")
                .style("width", "10px")
                .style("height", "10px")
                .style("background", colors[key])
                .style("border-radius", "2px");

            item.append("span")
                .style("color", "#94a3b8")
                .text(labels[key]);
        }
    });
}

function resetLeftPanel() {
    // Remove all country-specific sections
    d3.select("#country-name-section").remove();
    d3.select("#country-info-section").remove();
    d3.select("#stats-overview-section").remove();
    d3.select("#pie-chart-section").remove();

    // Also clear any remaining country data from left panel
    d3.select("#left-panel").selectAll(".country-view-section").remove();

    // Restore world view sections
    d3.select(".legend-section").style("display", "block");
    d3.select(".stats-container").style("display", "block");
    updateStats();
}

// ============================================================================
// STATISTICAL CHARTS
// ============================================================================

function getFilteredData() {
    // In faction mode, return faction events
    if (viewState.mode === 'faction' && viewState.selectedFactionData) {
        const currentYear = +document.getElementById('year-slider').value;
        let data = viewState.selectedFactionData.filter(d => d.year <= currentYear);

        if (viewState.selectedViolenceType) {
            data = data.filter(d => d.type_of_violence_name === viewState.selectedViolenceType);
        }

        return data;
    }

    // Existing country view logic
    if (!viewState.selectedCountryData) return [];

    let data = viewState.selectedCountryData.events;
    const currentYear = +document.getElementById('year-slider').value;

    data = data.filter(d => d.year <= currentYear);

    if (viewState.selectedViolenceType) {
        data = data.filter(d => d.type_of_violence_name === viewState.selectedViolenceType);
    }

    // Apply faction filter if active (from graph view)
    if (viewState.selectedFaction && viewState.mode !== 'faction') {
        data = data.filter(e => {
            const factionName = viewState.selectedFaction;
            const sideA = e.side_a || '';
            const sideB = e.side_b || '';
            return sideA.includes(factionName) || sideB.includes(factionName);
        });
    }

    return data;
}

// ============================================================================
// UNIFIED DASHBOARD UI - Integration Point
// This is the SINGLE function that renders statistics panel for both views
// ============================================================================

/**
 * Update Dashboard UI - Main integration function
 * Renders the right panel with charts using ChartRenderer
 * 
 * @param {Array} filteredEvents - Array of event objects (already filtered by country/faction)
 * @param {string} title - Title to display in the panel header
 * @param {string} subtitle - Subtitle to display (e.g., region name)
 */
function updateDashboardUI(filteredEvents, title, subtitle) {
    // Safety check - if ChartRenderer not loaded, skip
    if (typeof ChartRenderer === 'undefined') {
        console.warn('ChartRenderer not loaded, skipping dashboard update');
        return;
    }

    if (typeof dataManager === 'undefined') {
        console.warn('dataManager not loaded, skipping dashboard update');
        return;
    }

    // Show right panel
    const chartsPanel = d3.select("#charts-panel");
    chartsPanel.style("display", "flex");

    // Update panel header
    d3.select("#charts-title").text(title || "Statistics");
    d3.select("#charts-subtitle").text(subtitle || "Comprehensive Data");

    // Show standard chart containers, hide special views
    chartsPanel.selectAll(".chart-container").style("display", "block");
    d3.select("#top-countries-list").style("display", "none");
    d3.select("#event-text-details").style("display", "none");
    d3.select("#victim-chart-container").style("display", "none");
    d3.select("#chart-seasonality-container").style("display", "none");

    // Handle empty data
    if (!filteredEvents || filteredEvents.length === 0) {
        console.warn("No events data for charts");
        // Clear charts
        d3.select("#chart-timeline").selectAll("*").remove();
        d3.select("#chart-violence-type").selectAll("*").remove();
        d3.select("#chart-victims").selectAll("*").remove();
        d3.select("#chart-top-events").html('<p style="color: #94a3b8; text-align: center;">No events available</p>');
        return;
    }

    // Aggregate data for charts using DataManager
    const chartData = dataManager.aggregateDataForCharts(filteredEvents);

    // ========================================================================
    // RENDER CHARTS - Using ChartRenderer (SAME as Graph View!)
    // ========================================================================

    // Chart 1: Timeline (Casualties over time)
    ChartRenderer.drawTimelineChart(chartData.byYear, '#chart-timeline');

    // Chart 2: Violence Type Breakdown (Donut chart)
    ChartRenderer.drawViolenceTypeChart(chartData.byViolenceType, '#chart-violence-type');

    // Chart 3: Conflict Intensity Heatmap (Year-Month)
    ChartRenderer.drawYearMonthHeatmap(chartData.byMonth, '#chart-victims');

    // Chart 4: Top Events List
    ChartRenderer.renderTopEventsList(chartData.topEvents, '#chart-top-events', {
        onEventClick: (event) => selectEvent(event)
    });
}

/**
 * Update All Charts - Wrapper function for backward compatibility
 * Determines context and calls updateDashboardUI with appropriate params
 */
function updateAllCharts() {
    if (viewState.mode === 'world') {
        renderTopCountriesList();
    } else if (viewState.mode === 'country') {
        // Country view - get events and call unified dashboard
        const events = getFilteredData();
        const countryName = viewState.selectedCountryName || 'Country';
        const region = viewState.selectedCountryData?.region || '';
        updateDashboardUI(events, `${countryName} Statistics`, region);

    } else if (viewState.mode === 'faction') {
        // Faction view - use faction data
        const events = getFilteredData();
        const factionName = viewState.selectedFactionName || 'Faction';
        updateDashboardUI(events, 'Faction Statistics', factionName);

    } else if (viewState.mode === 'event') {
        renderEventDetailsView(viewState.selectedEvent);
    }
}

function renderTopCountriesList() {
    const container = d3.select("#charts-panel");
    container.style("display", "flex");
    d3.select("#charts-title").text("Top Countries");
    d3.select("#charts-subtitle").text("Comprehensive Statistics");

    // Clear existing charts
    d3.select("#chart-timeline").selectAll("*").remove();
    d3.select("#chart-violence-type").selectAll("*").remove();
    d3.select("#chart-victims").selectAll("*").remove();
    d3.select("#chart-top-events").html('');

    // Hide unused chart containers
    container.selectAll(".chart-container").style("display", "none");

    // Create or select Top Countries container
    let listContainer = container.select("#top-countries-list");
    if (listContainer.empty()) {
        listContainer = container.append("div")
            .attr("id", "top-countries-list")
            .attr("class", "chart-container")
            .style("display", "block");

        // Sorting Controls
        const controls = listContainer.append("div")
            .attr("class", "sort-controls")
            .style("display", "flex")
            .style("gap", "10px")
            .style("margin-bottom", "15px");

        const modes = [
            { id: 'casualties', label: 'Casualties' },
            { id: 'count', label: 'Conflicts' },
            { id: 'average', label: 'Average' }
        ];

        modes.forEach(mode => {
            controls.append("button")
                .attr("class", "sort-btn")
                .attr("data-mode", mode.id)
                .text(mode.label)
                .style("padding", "5px 10px")
                .style("border-radius", "4px")
                .style("border", "none")
                .style("cursor", "pointer")
                .style("background", "#334155")
                .style("color", "white")
                .style("font-size", "0.75rem")
                .on("click", function () {
                    viewState.countrySortMode = mode.id;
                    renderTopCountriesList(); // Re-render
                });
        });

        listContainer.append("div").attr("class", "events-list");
    } else {
        listContainer.style("display", "block");
    }

    // Update active button state
    listContainer.selectAll(".sort-btn")
        .style("background", function () { return this.getAttribute("data-mode") === viewState.countrySortMode ? "#2563eb" : "#334155"; })
        .style("opacity", function () { return this.getAttribute("data-mode") === viewState.countrySortMode ? "1" : "0.7"; });

    const currentYear = +document.getElementById('year-slider').value;

    // Aggregate data by country for current year
    // Filter by region if in region view mode
    let countriesData = processedData;
    if (viewState.mode === 'region' && viewState.selectedRegion) {
        countriesData = processedData.filter(c => c.region === viewState.selectedRegion);
        d3.select("#charts-subtitle").text(`${viewState.selectedRegion} - Comprehensive Statistics`);
    }

    const countryStats = countriesData.map(c => {
        // ✅ Filter events by year AND violence type
        let events = c.events.filter(e => e.year <= currentYear);

        // Apply violence type filter if selected
        if (viewState.selectedViolenceType) {
            events = events.filter(e => e.type_of_violence_name === viewState.selectedViolenceType);
        }

        const casualties = d3.sum(events, e => e.best);
        const count = events.length;
        return {
            name: c.name,
            region: c.region,
            casualties: casualties,
            count: count,
            average: count > 0 ? casualties / count : 0
        };
    })
        .filter(c => c.count > 0) // Only show countries with events
        .sort((a, b) => b[viewState.countrySortMode] - a[viewState.countrySortMode])
        .slice(0, 10);

    const list = listContainer.select(".events-list");
    list.html('');

    countryStats.forEach((c, i) => {
        const item = list.append("div")
            .attr("class", "event-item")
            .style("border-left-color", REGION_COLORS[c.region])
            .on("click", () => {
                // Use country data directly since we already have it from processedData
                const countryConflictData = processedData.find(country => country.name === c.name);
                if (!countryConflictData) {
                    console.warn(`No conflict data for: "${c.name}"`);
                    return;
                }

                // Find the map feature for visualization
                const countryFeature = findCountryFeature(c.name);
                if (countryFeature) {
                    // Directly enter country view with the data we have
                    enterCountryView(countryFeature, countryConflictData.name, countryConflictData);
                } else {
                    console.warn(`Could not find map feature for country: "${c.name}"`);
                }
            })
            .on("mouseenter", () => {
                // Highlight country on map using same matching logic
                const countryFeature = findCountryFeature(c.name);
                if (countryFeature) {
                    mapGroup.selectAll(".country")
                        .filter(f => f === countryFeature)
                        .style("stroke", "#fbbf24")
                        .style("stroke-width", "2px");
                }
            })
            .on("mouseleave", () => {
                // Remove highlight
                const countryFeature = findCountryFeature(c.name);
                if (countryFeature) {
                    mapGroup.selectAll(".country")
                        .filter(f => f === countryFeature)
                        .style("stroke", "#334155")
                        .style("stroke-width", "0.5px");
                }
            });

        item.append("div")
            .attr("class", "event-item-title")
            .text(`${i + 1}. ${c.name}`);

        let metaText = "";
        if (viewState.countrySortMode === 'casualties') {
            metaText = `<strong style="color: ${REGION_COLORS[c.region]};">${d3.format(",d")(c.casualties)}</strong> casualties`;
        } else if (viewState.countrySortMode === 'count') {
            metaText = `<strong style="color: ${REGION_COLORS[c.region]};">${c.count}</strong> conflicts`;
        } else {
            metaText = `<strong style="color: ${REGION_COLORS[c.region]};">${d3.format(",.1f")(c.average)}</strong> avg casualties`;
        }

        item.append("div")
            .attr("class", "event-item-meta")
            .html(metaText);
    });
}

function renderTopOpponentsList() {
    const container = d3.select("#charts-panel");

    // Create or select Top Opponents container
    let listContainer = container.select("#top-opponents-list");
    if (listContainer.empty()) {
        listContainer = container.insert("div", "#chart-top-events") // Insert before top events
            .attr("id", "top-opponents-list")
            .attr("class", "chart-container")
            .style("display", "block");
        listContainer.append("h4").text("Main Opponents (Side B)");
        listContainer.append("div").attr("class", "events-list");
    } else {
        listContainer.style("display", "block");
    }

    const data = getFilteredData();
    const opponents = d3.rollup(data, v => d3.sum(v, d => d.best), d => d.side_b);
    const topOpponents = Array.from(opponents, ([name, val]) => ({ name, val }))
        .sort((a, b) => b.val - a.val)
        .slice(0, 5);

    const list = listContainer.select(".events-list");
    list.html('');

    topOpponents.forEach((o, i) => {
        list.append("div")
            .attr("class", "event-item")
            .style("border-left-color", REGION_COLORS[viewState.selectedCountryData.region])
            .html(`
                <div class="event-item-title">${i + 1}. ${o.name}</div>
                <div class="event-item-meta">
                    <strong style="color: #ef4444;">${d3.format(",d")(o.val)}</strong> casualties
                </div>
            `);
    });
}

// Chart 1: Timeline
function drawTimelineChart() {
    const data = getFilteredData();
    if (data.length === 0) return;

    const yearData = d3.rollup(
        data,
        v => d3.sum(v, d => d.best),
        d => d.year
    );

    const chartData = Array.from(yearData, ([year, casualties]) => ({ year, casualties }))
        .sort((a, b) => a.year - b.year);

    const svg = d3.select("#chart-timeline");
    svg.selectAll("*").remove();

    const chartNode = d3.select("#chart-timeline").node();
    if (!chartNode || !chartNode.parentElement) {
        console.warn("Timeline chart container not found");
        return;
    }
    const container = chartNode.parentElement;
    const width = container.getBoundingClientRect().width || 300;
    const height = 180;
    const margin = { top: 10, right: 10, bottom: 30, left: 50 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    svg.attr("width", width).attr("height", height);

    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    const x = d3.scaleLinear()
        .domain(d3.extent(chartData, d => d.year))
        .range([0, innerWidth]);

    const y = d3.scaleLinear()
        .domain([0, d3.max(chartData, d => d.casualties)])
        .range([innerHeight, 0]);

    const line = d3.line()
        .x(d => x(d.year))
        .y(d => y(d.casualties))
        .curve(d3.curveMonotoneX);

    const area = d3.area()
        .x(d => x(d.year))
        .y0(innerHeight)
        .y1(d => y(d.casualties))
        .curve(d3.curveMonotoneX);

    g.append("path")
        .datum(chartData)
        .attr("fill", "rgba(59, 130, 246, 0.2)")
        .attr("d", area);

    g.append("path")
        .datum(chartData)
        .attr("fill", "none")
        .attr("stroke", "#3b82f6")
        .attr("stroke-width", 2)
        .attr("d", line);

    g.append("g")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(d3.axisBottom(x).ticks(5).tickFormat(d3.format("d")))
        .style("color", "#94a3b8")
        .style("font-size", "0.75rem");

    g.append("g")
        .call(d3.axisLeft(y).ticks(5).tickFormat(d3.format(".2s")))
        .style("color", "#94a3b8")
        .style("font-size", "0.75rem");
}

// Chart 2: Violence Type Breakdown (Pie Chart)
function drawViolenceTypeChart() {
    const data = getFilteredData();
    if (data.length === 0) return;

    const typeData = d3.rollup(
        data,
        v => d3.sum(v, d => d.best),
        d => d.type_of_violence_name
    );

    const chartData = Array.from(typeData, ([type, casualties]) => ({ type, casualties }))
        .filter(d => d.casualties > 0)
        .sort((a, b) => b.casualties - a.casualties);

    const svg = d3.select("#chart-violence-type");
    svg.selectAll("*").remove();

    const container = d3.select("#chart-violence-type").node().parentElement;
    const width = container.getBoundingClientRect().width || 300;
    const height = 200;
    const radius = Math.min(width, height) / 2 - 20;

    svg.attr("width", width).attr("height", height);

    const g = svg.append("g")
        .attr("transform", `translate(${width / 2},${height / 2})`);

    const pie = d3.pie()
        .value(d => d.casualties)
        .sort(null);

    const arc = d3.arc()
        .innerRadius(0)
        .outerRadius(radius * 0.85);

    const arcs = g.selectAll("arc")
        .data(pie(chartData))
        .enter()
        .append("g")
        .attr("class", "arc");

    arcs.append("path")
        .attr("d", arc)
        .attr("fill", d => TYPE_COLORS[d.data.type] || "#94a3b8")
        .attr("stroke", "#f8fafc")
        .style("stroke-width", "2px")
        .style("opacity", 0.85)
        .on("mouseover", function (event, d) {
            d3.select(this).style("opacity", 1).style("stroke", "#fff").style("stroke-width", "3px");
            g.append("text")
                .attr("class", "center-text")
                .attr("text-anchor", "middle")
                .attr("dy", "-0.5em")
                .style("fill", "#1e293b")
                .style("font-weight", "bold")
                .style("font-size", "0.9rem")
                .text(d.data.type);
            g.append("text")
                .attr("class", "center-text")
                .attr("text-anchor", "middle")
                .attr("dy", "1em")
                .style("fill", "#64748b")
                .style("font-size", "0.8rem")
                .text(d3.format(",d")(d.data.casualties));
        })
        .on("mouseout", function () {
            d3.select(this).style("opacity", 0.85).style("stroke", "#f8fafc").style("stroke-width", "2px");
            g.selectAll(".center-text").remove();
        });

    // Add legend
    const legend = g.append("g")
        .attr("transform", `translate(${-width / 2 + 10}, ${-height / 2 + 10})`);

    chartData.forEach((d, i) => {
        const legendRow = legend.append("g")
            .attr("transform", `translate(0, ${i * 18})`);

        legendRow.append("rect")
            .attr("width", 12)
            .attr("height", 12)
            .attr("fill", TYPE_COLORS[d.type] || "#94a3b8")
            .attr("rx", 2);

        legendRow.append("text")
            .attr("x", 18)
            .attr("y", 10)
            .style("fill", "#64748b")
            .style("font-size", "0.65rem")
            .text(d.type);
    });
}

// Chart 3: Year-Month Heatmap (Conflict Intensity) - Replaces Victim Composition in Country View
function drawYearMonthHeatmap() {
    const data = getFilteredData();
    if (data.length === 0) return;

    // Filter out data without valid month information
    const validData = data.filter(d => d.month !== null && d.month >= 1 && d.month <= 12);

    if (validData.length === 0) {
        console.warn("No valid month data available for heatmap");
        return;
    }

    // Use the existing chart-victims container from HTML
    const chartContainer = d3.select("#chart-victims").node()?.parentElement;
    if (!chartContainer) {
        console.error("chart-victims container not found");
        return;
    }

    // Add height expansion class
    d3.select("#chart-victims").classed("h-320", true);

    // Update the title
    d3.select(chartContainer).select("h4").text("Conflict Intensity (Year-Month)");

    const svg = d3.select("#chart-victims");
    svg.selectAll("*").remove();

    // Aggregate data by year and month
    const heatmapData = d3.rollup(
        validData,
        v => d3.sum(v, d => d.best),
        d => d.year,
        d => d.month
    );

    const years = Array.from(new Set(validData.map(d => d.year))).sort((a, b) => a - b);
    const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    const width = chartContainer.getBoundingClientRect().width || 380;
    const height = 320; // Set to 320px explicitly
    const margin = { top: 10, right: 15, bottom: 70, left: 60 }; // Increased left margin for full month names
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    svg.attr("width", width).attr("height", height);

    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    const cellWidth = innerWidth / years.length;
    const cellHeight = innerHeight / 12;

    // Prepare data array
    const dataArray = [];
    years.forEach(year => {
        for (let month = 1; month <= 12; month++) {
            const casualties = heatmapData.get(year)?.get(month) || 0;
            dataArray.push({ year, month, casualties });
        }
    });

    const maxCasualties = d3.max(dataArray, d => d.casualties) || 1;

    const colorScale = d3.scaleSequential()
        .domain([0, maxCasualties])
        .interpolator(d3.interpolateYlOrRd);

    // Draw cells
    g.selectAll("rect")
        .data(dataArray)
        .join("rect")
        .attr("x", d => years.indexOf(d.year) * cellWidth)
        .attr("y", d => (d.month - 1) * cellHeight)
        .attr("width", cellWidth - 1)
        .attr("height", cellHeight - 1)
        .attr("fill", d => d.casualties > 0 ? colorScale(d.casualties) : "#f1f5f9")
        .attr("stroke", "#fff")
        .attr("stroke-width", 0.5)
        .style("cursor", "pointer")
        .append("title")
        .text(d => `${months[d.month - 1]} ${d.year}: ${d3.format(",d")(d.casualties)} casualties`);

    // Y-axis (Months)
    const yAxis = d3.axisLeft(d3.scaleBand()
        .domain(months)
        .range([0, innerHeight]))
        .tickSize(0);

    g.append("g")
        .call(yAxis)
        .selectAll("text")
        .style("fill", "#64748b")
        .style("font-size", "0.65rem");

    // X-axis (Years) - show years every 5 years
    const xAxis = d3.axisBottom(d3.scaleBand()
        .domain(years)
        .range([0, innerWidth]))
        .tickValues(years.filter(y => y % 5 === 0))
        .tickSize(0);

    g.append("g")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(xAxis)
        .selectAll("text")
        .style("fill", "#64748b")
        .style("font-size", "0.55rem") // Slightly smaller font for all years
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end");

    g.selectAll(".domain").remove();
}

// Chart 5: Seasonality of Conflict (New)
function drawSeasonalityChart() {
    const data = getFilteredData();
    if (data.length === 0) return;

    // Aggregate by month (1-12)
    const monthData = d3.rollup(
        data,
        v => d3.sum(v, d => d.best),
        d => d.month
    );

    // Ensure all months are present
    const chartData = [];
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    for (let i = 1; i <= 12; i++) {
        chartData.push({
            month: months[i - 1],
            monthNum: i,
            casualties: monthData.get(i) || 0
        });
    }

    const container = d3.select("#charts-panel");
    let chartContainer = container.select("#chart-seasonality-container");

    if (chartContainer.empty()) {
        chartContainer = container.append("div") // Append instead of insert to avoid reference issues
            .attr("id", "chart-seasonality-container")
            .attr("class", "chart-container")
            .style("display", "block");
        chartContainer.append("h4").text("Seasonality of Conflict");
        chartContainer.append("svg").attr("id", "chart-seasonality");
    } else {
        chartContainer.style("display", "block");
    }

    const svg = d3.select("#chart-seasonality");
    svg.selectAll("*").remove();

    const width = chartContainer.node().getBoundingClientRect().width || 300;
    const height = 180;
    const margin = { top: 10, right: 10, bottom: 30, left: 40 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    svg.attr("width", width).attr("height", height);

    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    const x = d3.scaleBand()
        .domain(months)
        .range([0, innerWidth])
        .padding(0.2);

    const y = d3.scaleLinear()
        .domain([0, d3.max(chartData, d => d.casualties)])
        .range([innerHeight, 0]);

    // Add gradient
    const defs = svg.append("defs");
    const gradient = defs.append("linearGradient")
        .attr("id", "seasonality-gradient")
        .attr("x1", "0%")
        .attr("y1", "100%")
        .attr("x2", "0%")
        .attr("y2", "0%");

    gradient.append("stop").attr("offset", "0%").attr("stop-color", "#f59e0b"); // Amber
    gradient.append("stop").attr("offset", "100%").attr("stop-color", "#ef4444"); // Red

    g.selectAll(".bar")
        .data(chartData)
        .join("rect")
        .attr("class", "bar")
        .attr("x", d => x(d.month))
        .attr("y", d => y(d.casualties))
        .attr("width", x.bandwidth())
        .attr("height", d => innerHeight - y(d.casualties))
        .attr("fill", "url(#seasonality-gradient)")
        .attr("rx", 2);

    g.append("g")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(d3.axisBottom(x).tickSize(0))
        .selectAll("text")
        .style("color", "#94a3b8")
        .style("font-size", "0.65rem");

    g.append("g")
        .call(d3.axisLeft(y).ticks(4).tickFormat(d3.format(".2s")))
        .style("color", "#94a3b8")
        .style("font-size", "0.7rem");

    g.select(".domain").remove();
}

// Chart 4: Top Events (Renamed to Top Conflicts)
function renderTopEventsList() {
    const data = getFilteredData();
    if (data.length === 0) return;

    const topEvents = data
        .sort((a, b) => b.best - a.best)
        .slice(0, 10);

    const container = d3.select("#chart-top-events");
    if (container.empty()) {
        d3.select("#charts-panel").append("div").attr("id", "chart-top-events").attr("class", "events-list");
    } else {
        container.html('');
    }

    let title = d3.select("#top-events-title");
    if (title.empty()) {
        const chartContainer = d3.selectAll(".chart-container").filter(function () {
            return this.querySelector("#chart-top-events");
        });

        if (!chartContainer.empty()) {
            chartContainer.insert("h4", "#chart-top-events")
                .attr("id", "top-events-title")
                .text("Top Conflicts");
        } else {
            d3.select("#charts-panel").append("h4")
                .attr("id", "top-events-title")
                .text("Top Conflicts");
        }
    } else {
        title.text("Top Conflicts");
    }

    topEvents.forEach((event, i) => {
        const item = container.append("div")
            .attr("class", "event-item")
            .style("border-left-color", REGION_COLORS[event.region])
            .style("animation", `fadeIn 0.3s ease-out ${i * 0.05}s both`)
            .on("click", () => {
                selectEvent(event);
            });

        item.append("div")
            .attr("class", "event-item-title")
            .text(`${i + 1}. ${event.dyad_name || 'Unknown Event'}`);

        item.append("div")
            .attr("class", "event-item-meta")
            .html(`
                ${event.date_start || event.year} • 
                <strong style="color: #ef4444;">${d3.format(",d")(event.best)}</strong> casualties • 
                <span style="color: ${TYPE_COLORS[event.type_of_violence_name]};">${event.type_of_violence_name}</span>
            `);
    });
}

function renderEventDetailsView(d) {
    const container = d3.select("#charts-panel");
    container.style("display", "flex");
    d3.select("#charts-title").text("Event Details");
    d3.select("#charts-subtitle").text(d.dyad_name);

    // Hide all chart containers first
    container.selectAll(".chart-container").style("display", "none");

    // 1. Text Details - Reuse existing container with optimized updates
    let detailsContainer = container.select("#event-text-details");
    if (detailsContainer.empty()) {
        detailsContainer = container.append("div")
            .attr("id", "event-text-details")
            .attr("class", "chart-container");
    }

    detailsContainer
        .style("display", "block")
        .html(`
        <div class="country-info-item">
            <span class="country-info-label">Date:</span>
            <span class="country-info-value">${d.date_start || d.year}</span>
        </div>
        <div class="country-info-item">
            <span class="country-info-label">Side A:</span>
            <span class="country-info-value">${d.side_a}</span>
        </div>
        <div class="country-info-item">
            <span class="country-info-label">Side B:</span>
            <span class="country-info-value">${d.side_b}</span>
        </div>
        <div class="country-info-item">
            <span class="country-info-label">Casualties:</span>
            <span class="country-info-value" style="color: #ef4444;">${d3.format(",d")(d.best)}</span>
        </div>
        <div class="country-info-item" style="border-bottom: none; display: block;">
             <span class="country-info-label">Description:</span><br>
             <p style="color: #cbd5e1; font-size: 0.85rem; margin-top: 5px; line-height: 1.4;">
                ${d.where_description || 'No detailed description available.'}
             </p>
        </div>
    `);

    // 2. Victim Chart - Only render if casualties > 100
    if (d.best <= 100) {
        // Hide the victim chart container when not needed
        const victimChartContainer = container.selectAll(".chart-container").filter(function () {
            return d3.select(this).select("#chart-victims").size() > 0;
        });
        victimChartContainer.style("display", "none");
        return; // Early exit
    }

    // Pre-filter and sort victim data
    const victims = [
        { category: 'Country', deaths: d.deaths_a || 0 },
        { category: 'Opponent', deaths: d.deaths_b || 0 },
        { category: 'Civilians', deaths: d.deaths_civilians || 0 },
        { category: 'Unknown', deaths: d.deaths_unknown || 0 }
    ].filter(v => v.deaths > 0).sort((a, b) => b.deaths - a.deaths);

    // Find the chart-victims container in the HTML
    const victimChartContainer = container.selectAll(".chart-container").filter(function () {
        return d3.select(this).select("#chart-victims").size() > 0;
    });

    if (victimChartContainer.empty()) {
        console.error("chart-victims container not found");
        return;
    }

    victimChartContainer.style("display", "block");

    // Use requestAnimationFrame to batch chart rendering
    requestAnimationFrame(() => {
        const svg = d3.select("#chart-victims");
        const width = victimChartContainer.node().getBoundingClientRect().width || 300;
        const height = 260; // Increased height for labels
        const radius = Math.min(width, height - 60) / 2 - 30; // Leave space for labels and legend

        // Cache SVG dimensions and group if not already cached or size changed
        if (!cachedVictimChartSVG || cachedVictimChartSVG.attr("width") !== width.toString()) {
            svg.attr("width", width).attr("height", height);
            cachedVictimChartSVG = svg;
        }

        // Clear existing content more efficiently
        svg.selectAll("g").remove();

        const g = svg.append("g").attr("transform", `translate(${width / 2},${(height - 40) / 2})`);
        cachedVictimChartG = g;

        // Pre-defined color scale (avoid recreation)
        const color = d3.scaleOrdinal()
            .domain(['Country', 'Opponent', 'Civilians', 'Unknown'])
            .range(['#d62728', '#1f77b4', '#2ca02c', '#7f7f7f']);

        const pie = d3.pie().value(d => d.deaths).sort(null);
        const arc = d3.arc().innerRadius(radius * 0.5).outerRadius(radius * 0.8);
        const labelArc = d3.arc().innerRadius(radius * 0.9).outerRadius(radius * 0.9);

        // Calculate total for percentages
        const total = d3.sum(victims, v => v.deaths);

        // Use D3 update pattern for better performance
        const arcs = g.selectAll(".arc")
            .data(pie(victims), d => d.data.category);

        // Exit
        arcs.exit().remove();

        // Enter + Update
        const arcsEnter = arcs.enter()
            .append("g")
            .attr("class", "arc");

        arcsEnter.append("path")
            .attr("d", arc)
            .attr("fill", d => color(d.data.category))
            .attr("stroke", "#0f172a")
            .style("stroke-width", "2px")
            .style("opacity", 0.8)
            .on("mouseover", function (event, d) {
                d3.select(this).style("opacity", 1).style("stroke", "#fff");
            })
            .on("mouseout", function () {
                d3.select(this).style("opacity", 0.8).style("stroke", "#0f172a");
            });

        // Add persistent labels with percentages
        arcsEnter.append("text")
            .attr("class", "arc-label")
            .attr("transform", d => {
                const pos = labelArc.centroid(d);
                const midAngle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                pos[0] = radius * 1.1 * (midAngle < Math.PI ? 1 : -1);
                return `translate(${pos})`;
            })
            .attr("text-anchor", d => {
                const midAngle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                return midAngle < Math.PI ? "start" : "end";
            })
            .style("fill", "#0f172a")
            .style("font-size", "0.7rem")
            .style("font-weight", "600")
            .text(d => {
                const percentage = ((d.data.deaths / total) * 100).toFixed(1);
                return `${d.data.category}: ${percentage}%`;
            });

        // Add polylines connecting labels to segments
        arcsEnter.append("polyline")
            .attr("class", "arc-line")
            .attr("points", d => {
                const pos = labelArc.centroid(d);
                const midAngle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                const labelPos = [radius * 1.05 * (midAngle < Math.PI ? 1 : -1), pos[1]];
                return [arc.centroid(d), labelArc.centroid(d), labelPos];
            })
            .style("fill", "none")
            .style("stroke", "#94a3b8")
            .style("stroke-width", "1px")
            .style("opacity", 0.5);

        // Update existing arcs
        arcs.select("path")
            .attr("d", arc)
            .attr("fill", d => color(d.data.category));

        // Add legend at the bottom
        const legend = svg.append("g")
            .attr("class", "victim-legend")
            .attr("transform", `translate(10, ${height - 35})`);

        victims.forEach((v, i) => {
            const legendItem = legend.append("g")
                .attr("transform", `translate(${i * (width / victims.length)}, 0)`);

            legendItem.append("rect")
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", color(v.category))
                .attr("rx", 2);

            legendItem.append("text")
                .attr("x", 14)
                .attr("y", 9)
                .style("fill", "#64748b")
                .style("font-size", "0.65rem")
                .text(`${v.category} (${d3.format(",d")(v.deaths)})`);
        });
    });
}




// ============================================================================
// COUNTRY INFORMATION API
// ============================================================================

let countryInfoMap = new Map();

async function fetchCountryInfo() {
    try {
        const response = await fetch('https://restcountries.com/v3.1/all?fields=name,population,area,cca3,capital,capitalInfo');
        const data = await response.json();

        data.forEach(country => {
            countryInfoMap.set(country.name.common, {
                population: d3.format(",")(country.population),
                area: d3.format(",")(country.area) + " km²",
                areaNumeric: country.area, // Store numeric area for scaling calculations
                capital: country.capital ? country.capital[0] : null,
                capitalCoords: country.capitalInfo?.latlng ? [country.capitalInfo.latlng[1], country.capitalInfo.latlng[0]] : null // [lon, lat]
            });
        });

    } catch (error) {
        console.error("❌ Error fetching country info:", error);
    }
}

// ============================================================================
// LEGEND
// ============================================================================

function createLegend() {
    const legendContainer = d3.select("#legend");
    legendContainer.html('');

    Object.entries(REGION_COLORS).forEach(([region, color]) => {
        const item = legendContainer.append("div")
            .attr("class", "legend-item active")
            .attr("data-region", region)
            .on("click", () => {
                // Check if we're in graph view or map view
                if (graphViewActive) {
                    // In graph view: toggle region filter and update graph
                    if (viewState.selectedRegion === region) {
                        // ✅ Clicking same region = DESELECT & return to world
                        viewState.selectedRegion = null;
                        viewState.mode = 'world';
                        d3.select("#reset-zoom").style("display", "none");
                        // Remove selection highlight from all regions
                        d3.select("#legend").selectAll(".legend-item").classed("selected", false);
                        d3.select("#charts-title").text("Top Factions");
                    } else {
                        // ✅ Select new region with highlight
                        viewState.selectedRegion = region;
                        viewState.mode = 'region';
                        d3.select("#reset-zoom").style("display", "block");
                        // Add 'selected' class to clicked region only
                        d3.select("#legend").selectAll(".legend-item")
                            .classed("selected", function () {
                                return this.getAttribute("data-region") === region;
                            });
                        d3.select("#charts-title").text(`Top Factions - ${region}`);
                    }
                    // Update graph view with new filter
                    if (typeof updateGraphView !== 'undefined') {
                        updateGraphView();
                    }
                } else {
                    // In map view: use existing toggle region behavior
                    toggleRegion(region);
                }
            });

        item.append("div")
            .attr("class", "legend-color")
            .style("background-color", color);

        item.append("span").text(region);

        // ✅ Set initial 'selected' class if this region is currently selected
        item.classed("selected", viewState.selectedRegion === region);
    });
}

// Create Violence Type Filter (works across all views)
function createViolenceTypeFilter() {
    const filterContainer = d3.select("#violence-type-filter");
    filterContainer.html('');

    Object.entries(TYPE_COLORS).forEach(([type, color]) => {
        const item = filterContainer.append("div")
            .attr("class", "legend-item active")
            .attr("data-type", type)
            .style("cursor", "pointer")
            .style("transition", "all 0.2s")
            .classed("selected", viewState.selectedViolenceType === type)
            .on("click", () => {
                // Toggle violence type filter
                if (viewState.selectedViolenceType === type) {
                    viewState.selectedViolenceType = null;
                } else {
                    viewState.selectedViolenceType = type;
                }

                // Update visual state
                filterContainer.selectAll(".legend-item")
                    .classed("selected", function () {
                        return this.getAttribute("data-type") === viewState.selectedViolenceType;
                    })
                    .style("opacity", function () {
                        const itemType = this.getAttribute("data-type");
                        const isSelected = itemType === viewState.selectedViolenceType;
                        const hasSelection = viewState.selectedViolenceType !== null;
                        return isSelected || !hasSelection ? "1" : "0.5";
                    });

                // Refresh current view
                if (viewState.mode === 'world') {
                    drawConflictBubbles();
                    renderTopCountriesList();
                    updateStats();
                } else if (viewState.mode === 'region') {
                    // ✅ STAY in region view, just refresh (force=true to skip toggle)
                    toggleRegion(viewState.selectedRegion, true);
                } else if (viewState.mode === 'country') {
                    drawIndividualEventBubbles();
                    updateAllCharts();
                    updateLeftPanel();
                    updateStats(); // Also update Overview Statistics
                }

                // Update graph view if active
                if (typeof updateGraphView !== 'undefined' && graphViewActive) {
                    updateGraphView();
                }
            });

        item.append("div")
            .attr("class", "legend-color")
            .style("background-color", color);

        item.append("span").text(type);

        // ✅ Ensure items are always fully visible (not grayed out)
        item.style("opacity", "1")
            .style("pointer-events", "auto");
    });
}


// Draw regional stacked bars in Overview Statistics
function drawRegionalStackedBars(data) {
    // Remove existing bars
    d3.select("#regional-bars").remove();

    // Calculate regional breakdown
    const regionalData = d3.rollup(
        data,
        v => ({
            events: v.length,
            casualties: d3.sum(v, d => d.best)
        }),
        d => d.region
    );

    const totalEvents = data.length;
    const totalCasualties = d3.sum(data, d => d.best);

    // Create container after Total Casualties
    const container = d3.select(".stats-container")
        .append("div")
        .attr("id", "regional-bars")
        .style("margin-top", "1rem");

    // Events bar
    container.append("div")
        .style("margin-bottom", "0.75rem")
        .html(`
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.25rem;">Events by Region</div>
            <div id="events-bar" style="display: flex; height: 20px; border-radius: 4px; overflow: hidden;"></div>
        `);

    const eventsBar = container.select("#events-bar");
    Object.entries(REGION_COLORS).forEach(([region, color]) => {
        const regionStats = regionalData.get(region);
        if (regionStats && regionStats.events > 0) {
            const percentage = (regionStats.events / totalEvents) * 100;
            eventsBar.append("div")
                .style("width", `${percentage}%`)
                .style("background", color)
                .style("height", "100%")
                .attr("title", `${region}: ${d3.format(",d")(regionStats.events)} events (${d3.format(".1f")(percentage)}%)`);
        }
    });

    // Casualties bar
    container.append("div")
        .html(`
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.25rem;">Casualties by Region</div>
            <div id="casualties-bar" style="display: flex; height: 20px; border-radius: 4px; overflow: hidden;"></div>
        `);

    const casualtiesBar = container.select("#casualties-bar");
    Object.entries(REGION_COLORS).forEach(([region, color]) => {
        const regionStats = regionalData.get(region);
        if (regionStats && regionStats.casualties > 0) {
            const percentage = (regionStats.casualties / totalCasualties) * 100;
            casualtiesBar.append("div")
                .style("width", `${percentage}%`)
                .style("background", color)
                .style("height", "100%")
                .attr("title", `${region}: ${d3.format(",d")(regionStats.casualties)} casualties (${d3.format(".1f")(percentage)}%)`);
        }
    });
}

// Draw violence type stacked chart in Overview Statistics (for regional view)
function drawViolenceTypeStackedChart(data) {
    // Remove existing bars
    d3.select("#regional-bars").remove();

    // Calculate violence type breakdown
    const typeData = d3.rollup(
        data,
        v => ({
            events: v.length,
            casualties: d3.sum(v, d => d.best)
        }),
        d => d.type_of_violence_name
    );

    const totalEvents = data.length;
    const totalCasualties = d3.sum(data, d => d.best);

    // Create container after Total Casualties
    const container = d3.select(".stats-container")
        .append("div")
        .attr("id", "regional-bars")
        .style("margin-top", "1rem");

    // Combined title
    container.append("div")
        .style("font-size", "0.8rem")
        .style("color", "var(--text-primary)")
        .style("font-weight", "600")
        .style("margin-bottom", "0.75rem")
        .text("Breakdown by Violence Type");

    // Events bar with label
    const eventsSection = container.append("div")
        .style("margin-bottom", "0.75rem");

    eventsSection.append("div")
        .style("display", "flex")
        .style("justify-content", "space-between")
        .style("align-items", "center")
        .style("margin-bottom", "0.25rem")
        .html(`
            <span style="font-size: 0.7rem; color: var(--text-muted);">Events</span>
            <span style="font-size: 0.7rem; color: var(--text-muted); font-weight: 600;">${d3.format(",d")(totalEvents)}</span>
        `);

    const eventsBar = eventsSection.append("div")
        .attr("id", "events-bar")
        .style("display", "flex")
        .style("height", "24px")
        .style("border-radius", "4px")
        .style("overflow", "hidden")
        .style("box-shadow", "0 1px 3px rgba(0,0,0,0.1)");

    Object.entries(TYPE_COLORS).forEach(([type, color]) => {
        const typeStats = typeData.get(type);
        if (typeStats && typeStats.events > 0) {
            const percentage = (typeStats.events / totalEvents) * 100;
            eventsBar.append("div")
                .style("width", `${percentage}%`)
                .style("background", color)
                .style("height", "100%")
                .style("position", "relative")
                .style("cursor", "pointer")
                .attr("title", `${type}: ${d3.format(",d")(typeStats.events)} events (${d3.format(".1f")(percentage)}%)`)
                .on("mouseover", function () {
                    d3.select(this).style("opacity", "0.8");
                })
                .on("mouseout", function () {
                    d3.select(this).style("opacity", "1");
                });
        }
    });

    // Casualties bar with label
    const casualtiesSection = container.append("div")
        .style("margin-bottom", "0.5rem");

    casualtiesSection.append("div")
        .style("display", "flex")
        .style("justify-content", "space-between")
        .style("align-items", "center")
        .style("margin-bottom", "0.25rem")
        .html(`
            <span style="font-size: 0.7rem; color: var(--text-muted);">Casualties</span>
            <span style="font-size: 0.7rem; color: #ef4444; font-weight: 600;">${d3.format(",d")(totalCasualties)}</span>
        `);

    const casualtiesBar = casualtiesSection.append("div")
        .attr("id", "casualties-bar")
        .style("display", "flex")
        .style("height", "24px")
        .style("border-radius", "4px")
        .style("overflow", "hidden")
        .style("box-shadow", "0 1px 3px rgba(0,0,0,0.1)");

    Object.entries(TYPE_COLORS).forEach(([type, color]) => {
        const typeStats = typeData.get(type);
        if (typeStats && typeStats.casualties > 0) {
            const percentage = (typeStats.casualties / totalCasualties) * 100;
            casualtiesBar.append("div")
                .style("width", `${percentage}%`)
                .style("background", color)
                .style("height", "100%")
                .style("position", "relative")
                .style("cursor", "pointer")
                .attr("title", `${type}: ${d3.format(",d")(typeStats.casualties)} casualties (${d3.format(".1f")(percentage)}%)`)
                .on("mouseover", function () {
                    d3.select(this).style("opacity", "0.8");
                })
                .on("mouseout", function () {
                    d3.select(this).style("opacity", "1");
                });
        }
    });

    // Add legend with clickable filters
    const legend = container.append("div")
        .style("display", "flex")
        .style("gap", "8px")
        .style("margin-top", "0.5rem")
        .style("flex-wrap", "wrap")
        .style("padding-top", "0.5rem")
        .style("border-top", "1px solid var(--border-color)");

    Object.entries(TYPE_COLORS).forEach(([type, color]) => {
        const typeStats = typeData.get(type);
        if (typeStats && (typeStats.events > 0 || typeStats.casualties > 0)) {
            const item = legend.append("div")
                .style("display", "flex")
                .style("align-items", "center")
                .style("gap", "4px")
                .style("font-size", "0.65rem")
                .style("cursor", "pointer")
                .style("padding", "4px 6px")
                .style("border-radius", "4px")
                .style("background", viewState.selectedViolenceType === type ? "rgba(37, 99, 235, 0.1)" : "transparent")
                .style("border", viewState.selectedViolenceType === type ? "1px solid #2563eb" : "1px solid transparent")
                .style("transition", "all 0.2s")
                .on("click", function () {
                    // Toggle filter
                    if (viewState.selectedViolenceType === type) {
                        viewState.selectedViolenceType = null;
                    } else {
                        viewState.selectedViolenceType = type;
                    }
                    // Refresh the view
                    toggleRegion(viewState.selectedRegion);
                })
                .on("mouseover", function () {
                    if (viewState.selectedViolenceType !== type) {
                        d3.select(this).style("background", "rgba(100, 116, 139, 0.1)");
                    }
                })
                .on("mouseout", function () {
                    if (viewState.selectedViolenceType !== type) {
                        d3.select(this).style("background", "transparent");
                    }
                });

            item.append("div")
                .style("width", "10px")
                .style("height", "10px")
                .style("background", color)
                .style("border-radius", "2px");

            item.append("span")
                .style("color", "var(--text-muted)")
                .text(type);
        }
    });
}

function toggleRegion(region, forceRefresh = false) {
    // ✅ Toggle logic: If clicking same region, DESELECT and return to world view
    // BUT skip if this is a forced refresh (from violence filter)
    if (!forceRefresh && viewState.mode === 'region' && viewState.selectedRegion === region) {
        returnToWorldView();
        return; // Exit early
    }

    // Enter region view mode
    viewState.mode = 'region';
    viewState.selectedRegion = region;
    updateStats();

    // ✅ Keep violence filter visible for combo filtering
    d3.select(".violence-filter-section").style("display", "block");

    // Keep sphere and graticule visible
    mapGroup.select(".sphere").style("display", "block").style("opacity", 1);
    mapGroup.select(".graticule").style("display", "block").style("opacity", 0.5);

    // Get country names with conflict data in this region
    const regionCountryNames = processedData
        .filter(c => c.region === region)
        .map(c => c.name);

    // Keep ALL countries visible at FULL opacity (to avoid hiding mislabeled countries)
    mapGroup.selectAll(".country")
        .style("display", "block")
        .transition()
        .duration(500)
        .style("opacity", 1) // All countries at full opacity
        .style("pointer-events", "auto"); // All countries remain clickable

    // Draw bubbles for region countries
    bubblesGroup.selectAll(".conflict-bubble").remove();

    const currentYear = +document.getElementById('year-slider').value;

    // Use dataFilterManager for optimized region filtering
    const filterOptions = { year: currentYear };
    if (viewState.selectedViolenceType) {
        filterOptions.violenceType = viewState.selectedViolenceType;
    }
    const currentYearData = dataFilterManager.getRegionEvents(region, filterOptions);

    const currentCountryData = aggregationManager.aggregateByCountry(currentYearData, countryData);

    let filteredCountries = currentCountryData.filter(d => d.coordinates);

    const maxCasualties = d3.max(filteredCountries, d => d.totalCasualties) || 1;
    const zoomFactor = viewState.zoomScale || 1;
    const baseRange = [5 / zoomFactor, 40 / zoomFactor];

    const radiusScale = d3.scaleSqrt()
        .domain([0, maxCasualties])
        .range(baseRange);

    bubblesGroup.selectAll(".conflict-bubble")
        .data(filteredCountries, d => d.name)
        .join("circle")
        .attr("class", "conflict-bubble")
        .attr("cx", d => projection(d.coordinates)[0])
        .attr("cy", d => projection(d.coordinates)[1])
        .attr("r", d => radiusScale(d.totalCasualties))
        .style("fill", d => REGION_COLORS[d.region])
        .style("cursor", "pointer")
        .style("opacity", 0.7)
        .on("click", handleBubbleClick);

    // Zoom to region
    zoomToRegion(region);

    // Show reset button
    d3.select("#reset-zoom").style("display", "block");

    // Show Top Countries panel for this region
    d3.select("#charts-panel").style("display", "flex");
    d3.select("#charts-title").text(`Top Countries - ${region}`);
    renderTopCountriesList();

    // Update legend visual feedback
    d3.selectAll(".legend-item")
        .classed("active", function () {
            return this.getAttribute("data-region") === region;
        });
}

function zoomToRegion(region) {
    // Find all countries in this region
    const regionCountries = processedData.filter(c => c.region === region);
    if (regionCountries.length === 0) return;

    // Calculate bounds
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    regionCountries.forEach(c => {
        if (c.coordinates) {
            const [x, y] = projection(c.coordinates);
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        }
    });

    if (minX === Infinity) return;

    // Add padding
    const padding = 50;
    const width = maxX - minX;
    const height = maxY - minY;
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    const scale = Math.min(8, 0.9 / Math.max(width / mapWidth, height / mapHeight));
    const translate = [mapWidth / 2 - scale * cx, mapHeight / 2 - scale * cy];

    svg.transition()
        .duration(750)
        .call(
            zoom.transform,
            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
        );
}

// ============================================================================
// TIME SLIDER & MODAL LOGIC
// ============================================================================

function createTimeSlider() {
    const slider = document.getElementById('year-slider');
    const currentYearDisplay = document.getElementById('year-current');
    const playBtn = document.getElementById('play-btn');
    let playInterval;

    // OPTIMIZED: Use throttle instead of debounce for responsive slider (50ms)
    const throttledUpdate = throttle((year) => {
        updateMapForYear(year);
    }, 50);

    slider.addEventListener('input', function () {
        currentYearDisplay.textContent = this.value;
        throttledUpdate(this.value);
    });

    playBtn.addEventListener('click', function () {
        if (playInterval) {
            clearInterval(playInterval);
            playInterval = null;
            this.textContent = "▶ Play";
        } else {
            this.textContent = "⏸ Pause";
            playInterval = setInterval(() => {
                let val = +slider.value;
                if (val >= +slider.max) val = +slider.min;
                else val++;

                slider.value = val;
                currentYearDisplay.textContent = val;
                updateMapForYear(val);

                if (val === +slider.max) {
                    clearInterval(playInterval);
                    playInterval = null;
                    playBtn.textContent = "▶ Play";
                }
            }, 500); // 0.5s per year
        }
    });
}

// OPTIMIZED: Track pending RAF update for cancellation
let pendingMapUpdate = null;

function updateMapForYear(year) {
    // Cancel any pending update to avoid stacking
    if (pendingMapUpdate) {
        cancelAnimationFrame(pendingMapUpdate);
    }

    // Batch all DOM updates in a single RAF call
    pendingMapUpdate = requestAnimationFrame(() => {
        // OPTIMIZED: Interrupt any running transitions before starting new ones
        bubblesGroup.selectAll(".conflict-bubble, .event-bubble").interrupt();

        updateStats();

        if (viewState.mode === 'world') {
            drawConflictBubbles();
            renderTopCountriesList();
        } else if (viewState.mode === 'region') {
            toggleRegion(viewState.selectedRegion, true); // true = forceRefresh
        } else if (viewState.mode === 'country') {
            drawIndividualEventBubbles();
            updateAllCharts();
            updateLeftPanel();
        }

        // Update graph view if active
        if (typeof updateGraphView !== 'undefined' && graphViewActive) {
            updateGraphView();
        }

        pendingMapUpdate = null;
    });
}

function setupModal() {
    const modal = document.getElementById('event-modal');
    const closeBtn = document.querySelector('.close-modal');

    closeBtn.onclick = function () {
        modal.style.display = "none";
    }

    window.onclick = function (event) {
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }
}

function setupBackButton() {
    const resetBtn = document.getElementById('reset-zoom');
    if (resetBtn) {
        // Remove any existing handlers first
        resetBtn.replaceWith(resetBtn.cloneNode(true));
        const newResetBtn = document.getElementById('reset-zoom');

        newResetBtn.addEventListener('click', function () {
            // Use unified back navigation
            navigateBack();
        });
    }
}

// Setup view mode toggle buttons (Map View / Graph View)
function setupViewToggle() {
    const mapViewBtn = document.getElementById('map-view-btn');
    const graphViewBtn = document.getElementById('graph-view-btn');

    if (mapViewBtn) {
        mapViewBtn.addEventListener('click', function () {
            toggleViewMode('map');
        });
    }

    if (graphViewBtn) {
        graphViewBtn.addEventListener('click', function () {
            toggleViewMode('graph');
        });
    }
}

// Toggle between map and graph views
function toggleViewMode(mode) {
    const mapContainer = document.getElementById('world-map');
    const graphContainer = document.getElementById('graph-container');
    const mapViewBtn = document.getElementById('map-view-btn');
    const graphViewBtn = document.getElementById('graph-view-btn');
    const relationshipFilterSection = document.getElementById('relationship-filter-section');

    // CRITICAL: Clear panel contents before switching views
    cleanupPanelsForViewSwitch();

    if (mode === 'graph') {
        // Switch to graph view
        mapContainer.style.display = 'none';
        graphContainer.style.display = 'block';
        mapViewBtn.classList.remove('active');
        graphViewBtn.classList.add('active');

        // Show relationship filter section for graph view
        if (relationshipFilterSection) {
            relationshipFilterSection.style.display = 'block';
        }

        // Initialize graph view
        if (typeof initGraphView !== 'undefined') {
            initGraphView();
        }
    } else {
        // Switch to map view
        graphContainer.style.display = 'none';
        mapContainer.style.display = 'block';
        graphViewBtn.classList.remove('active');
        mapViewBtn.classList.add('active');

        // Hide relationship filter section in map view
        if (relationshipFilterSection) {
            relationshipFilterSection.style.display = 'none';
        }

        // Stop graph simulation if active
        if (typeof allFactionsSimulation !== 'undefined' && allFactionsSimulation) {
            allFactionsSimulation.stop();
        }

        // Reset graph view state
        if (typeof graphViewActive !== 'undefined') {
            graphViewActive = false;
        }
        if (typeof allFactionsActive !== 'undefined') {
            allFactionsActive = false;
        }

        // Refresh map view
        updateStats();
        drawConflictBubbles();
        renderTopCountriesList();
    }
}

// Cleanup panels when switching between views
function cleanupPanelsForViewSwitch() {
    const leftPanel = d3.select("#left-panel");
    const rightPanel = d3.select("#charts-panel");

    // Remove faction-specific panels from graph view
    leftPanel.select("#faction-info-panel").remove();

    // Remove country-specific panels from map view
    leftPanel.select("#country-info-section").remove();
    leftPanel.select("#stats-overview-section").remove();
    leftPanel.select("#pie-chart-section").remove();

    // Remove regional breakdown bars
    leftPanel.select("#regional-bars").remove();

    // Clear right panel contents
    rightPanel.selectAll("*").remove();

    // Reset left panel visibility
    leftPanel.select(".stats-container").style("display", "block");
    leftPanel.select(".legend-section").style("display", "block");
    leftPanel.select(".violence-filter-section").style("display", "block");

    // Hide right panel by default (will be shown by specific views as needed)
    rightPanel.style("display", "none");
}

function returnToWorldView() {
    // Reset view state
    viewState.mode = 'world';
    viewState.selectedCountryName = null;
    viewState.selectedCountryData = null;
    viewState.selectedConflictType = null;
    viewState.selectedEvent = null;
    viewState.selectedRegion = null;
    viewState.selectedViolenceType = null;

    // Hide reset button
    d3.select("#reset-zoom").style("display", "none");

    // Hide right panel
    d3.select("#charts-panel").style("display", "none");

    // ✅ COMPREHENSIVE LEFT PANEL CLEANUP - Remove ALL country-specific sections
    d3.select("#country-info-section").remove();
    d3.select("#stats-overview-section").remove();
    d3.select("#country-name-section").remove();  // ← ADD THIS
    d3.select("#pie-chart-section").remove();     // ← ADD THIS

    // Also remove any elements with country-view-section class
    const leftPanel = d3.select("#left-panel");
    leftPanel.selectAll(".country-view-section").remove();

    // ✅ REBUILD UI from scratch
    createLegend();             // Re-create Regions legend!
    createViolenceTypeFilter(); // Re-create Violence Type filter

    // Restore ALL sections visibility
    d3.select(".stats-container").style("display", "block");
    d3.select(".legend-section").style("display", "block");
    d3.select(".violence-filter-section").style("display", "block");

    // Reset zoom
    svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity);

    // Restore sphere and graticule
    mapGroup.select(".sphere")
        .style("display", "block")
        .transition()
        .duration(500)
        .style("opacity", 1);

    mapGroup.select(".graticule")
        .style("display", "block")
        .transition()
        .duration(500)
        .style("opacity", 0.1);

    // Restore all countries to full opacity
    mapGroup.selectAll(".country")
        .style("display", "block")
        .style("pointer-events", "auto")
        .transition()
        .duration(500)
        .style("opacity", 1);

    // Clear event bubbles
    bubblesGroup.selectAll(".event-bubble").remove();
    bubblesGroup.selectAll(".capital-marker").remove();

    // Redraw world conflict bubbles
    setTimeout(() => {
        drawConflictBubbles();
        updateStats();
        renderTopCountriesList();
    }, 100);
}

function showEventDetails(d) {
    viewState.mode = 'event';
    viewState.selectedEvent = d;
    updateAllCharts();
}

// ============================================================================
// INITIALIZATION
// ============================================================================

async function init() {


    initializeMap();
    await fetchCountryInfo(); // Fetch API data
    await drawWorldMap();
    await loadData();
    drawConflictBubbles();

    // Show Top Countries panel in world view
    renderTopCountriesList();

    // Verify all countries can be mapped (diagnostic)
    setTimeout(() => {
        verifyCountryMappings();
    }, 1000);

    // Setup panel collapse functionality
    setupPanelCollapse();
}

// ============================================================================
// MODERN PANEL COLLAPSE FUNCTIONALITY - Hover to Reveal
// ============================================================================

function setupPanelCollapse() {
    const leftPanel = document.getElementById('left-panel');
    const rightPanel = document.getElementById('charts-panel');
    const leftToggleBtn = document.getElementById('left-panel-toggle');
    const rightToggleBtn = document.getElementById('right-panel-toggle');
    const leftRevealTrigger = document.getElementById('left-reveal-trigger');
    const rightRevealTrigger = document.getElementById('right-reveal-trigger');
    const contentWrapper = document.querySelector('.content-wrapper');
    const timeSlider = document.querySelector('.time-slider-container');

    let hideButtonTimeout = null;
    const EDGE_DISTANCE = 80; // pixels from edge to trigger button reveal
    const HIDE_DELAY = 1500; // ms to wait before auto-hiding buttons

    // Toggle functions - panels toggle on/off when buttons are clicked
    if (leftToggleBtn) {
        leftToggleBtn.addEventListener('click', () => {
            const isCollapsed = leftPanel.classList.toggle('collapsed');
            leftToggleBtn.classList.toggle('collapsed', isCollapsed);
            updateLayoutAndCenter();
            leftToggleBtn.innerHTML = isCollapsed ? '▶' : '◀';
        });
    }

    if (rightToggleBtn) {
        rightToggleBtn.addEventListener('click', () => {
            const isCollapsed = rightPanel.classList.toggle('collapsed');
            rightToggleBtn.classList.toggle('collapsed', isCollapsed);
            updateLayoutAndCenter();
            rightToggleBtn.innerHTML = isCollapsed ? '◀' : '▶';
        });
    }

    // Mouse proximity detection for auto-show/hide
    document.addEventListener('mousemove', (e) => {
        const mouseX = e.clientX;
        const windowWidth = window.innerWidth;

        clearTimeout(hideButtonTimeout);

        const isNearLeftEdge = mouseX < EDGE_DISTANCE;
        const isNearRightEdge = mouseX > windowWidth - EDGE_DISTANCE;

        // Show left button when near left edge
        if (isNearLeftEdge && leftToggleBtn) {
            leftToggleBtn.style.opacity = '1';
            leftToggleBtn.style.pointerEvents = 'auto';
        }

        // Show right button when near right edge
        if (isNearRightEdge && rightToggleBtn) {
            rightToggleBtn.style.opacity = '1';
            rightToggleBtn.style.pointerEvents = 'auto';
        }

        // Auto-hide after delay when mouse moves away
        hideButtonTimeout = setTimeout(() => {
            if (leftToggleBtn && mouseX >= EDGE_DISTANCE) {
                leftToggleBtn.style.opacity = '0';
                leftToggleBtn.style.pointerEvents = 'none';
            }
            if (rightToggleBtn && mouseX <= windowWidth - EDGE_DISTANCE) {
                rightToggleBtn.style.opacity = '0';
                rightToggleBtn.style.pointerEvents = 'none';
            }
        }, HIDE_DELAY);
    });

    // Keep buttons visible when hovering over them
    [leftToggleBtn, rightToggleBtn].forEach(btn => {
        if (btn) {
            btn.addEventListener('mouseenter', () => {
                clearTimeout(hideButtonTimeout);
                btn.style.opacity = '1';
                btn.style.pointerEvents = 'auto';
            });
        }
    });

    // Helper functions to hide panels
    function hideLeftPanel() {
        if (!leftPanel.classList.contains('collapsed')) {
            leftPanel.classList.add('collapsed');
            if (leftToggleBtn) {
                leftToggleBtn.classList.add('collapsed');
                leftToggleBtn.innerHTML = '▶';
            }
            updateLayoutAndCenter();
        }
    }

    function hideRightPanel() {
        if (!rightPanel.classList.contains('collapsed')) {
            rightPanel.classList.add('collapsed');
            if (rightToggleBtn) {
                rightToggleBtn.classList.add('collapsed');
                rightToggleBtn.innerHTML = '◀';
            }
            updateLayoutAndCenter();
        }
    }

    // Update grid layout, center content, and adjust time slider
    function updateLayoutAndCenter() {
        const leftCollapsed = leftPanel.classList.contains('collapsed');
        const rightCollapsed = rightPanel.classList.contains('collapsed');

        // Remove all collapse classes
        contentWrapper.classList.remove('left-collapsed', 'right-collapsed', 'both-collapsed');

        // Add appropriate class
        if (leftCollapsed && rightCollapsed) {
            contentWrapper.classList.add('both-collapsed');
        } else if (leftCollapsed) {
            contentWrapper.classList.add('left-collapsed');
        } else if (rightCollapsed) {
            contentWrapper.classList.add('right-collapsed');
        }

        // Adjust time slider width based on panel states
        // Make it wider when panels are collapsed
        if (timeSlider) {
            if (leftCollapsed && rightCollapsed) {
                timeSlider.style.width = '80%';
            } else if (leftCollapsed || rightCollapsed) {
                timeSlider.style.width = '70%';
            } else {
                timeSlider.style.width = '60%';
            }
        }

        // Wait for CSS transition, then recalculate and center visualizations
        setTimeout(() => {
            updateVisualizationDimensions();
        }, 450); // Slightly longer than CSS transition (400ms)
    }

    function updateVisualizationDimensions() {
        // Update graph dimensions if active
        if (typeof allFactionsSimulation !== 'undefined' && allFactionsSimulation) {
            const graphContainer = document.getElementById("graph-container");
            const width = graphContainer.clientWidth;
            const height = graphContainer.clientHeight;

            const graphSvg = d3.select("#graph-svg");
            graphSvg.attr("width", width).attr("height", height);

            // Update horizontal layout forces
            const nodes = allFactionsSimulation.nodes();
            if (nodes.length > 0) {
                const regionKeys = Object.keys(REGION_COLORS);
                const numRegions = regionKeys.length;
                const padding = 100;
                const usableWidth = width - padding * 2;

                // Update X force to keep nodes in their region zones
                allFactionsSimulation.force("x", d3.forceX().strength(0.1).x(d => {
                    const regionIndex = regionKeys.indexOf(d.region);
                    const regionWidth = usableWidth / numRegions;
                    return padding + regionIndex * regionWidth + regionWidth / 2;
                }));

                // Update Y force to center vertically
                allFactionsSimulation.force("y", d3.forceY().strength(0.05).y(height / 2));

                // Remove old circular forces if they exist
                allFactionsSimulation.force("radial", null);
                allFactionsSimulation.force("center", null);
            }

            // Gentle restart
            allFactionsSimulation.alpha(0.3).restart();
        }

        // Update map dimensions and projection
        if (typeof svg !== 'undefined' && svg) {
            const mapSection = document.querySelector('.map-section');
            if (mapSection) {
                const mapWidth = mapSection.clientWidth;
                const mapHeight = mapSection.clientHeight;

                svg.attr('width', mapWidth).attr('height', mapHeight);

                // Update projection if needed
                if (typeof projection !== 'undefined' && projection) {
                    projection
                        .scale(mapWidth / 6.5)
                        .translate([mapWidth / 2, mapHeight / 2]);

                    // Redraw map elements with new projection
                    if (viewState.mode === 'world') {
                        mapGroup.selectAll('.country').attr('d', path);
                        mapGroup.selectAll('.sphere').attr('d', path);
                        mapGroup.selectAll('.graticule').attr('d', path);
                    }
                }
            }
        }
    }
}


init();
