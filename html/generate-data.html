<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate Statistics Data - Comprehensive Export</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .subtitle {
            color: #94a3b8;
            margin-bottom: 30px;
            font-size: 1rem;
        }

        .status-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h2 {
            color: #667eea;
            font-size: 1.2rem;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #progress {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            margin: 20px 0;
        }

        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 12px;
        }

        #progress-text {
            text-align: center;
            font-size: 0.9rem;
            color: #94a3b8;
            margin-top: 8px;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 16px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
        }

        .log-entry {
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .log-entry.success {
            color: #22c55e;
        }

        .log-entry.error {
            color: #ef4444;
        }

        .log-entry.info {
            color: #3b82f6;
        }

        .log-entry.warn {
            color: #f59e0b;
        }

        .log-entry .time {
            color: #64748b;
            margin-right: 10px;
        }

        /* Data Summary Cards */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }

        .summary-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 16px;
            text-align: center;
        }

        .summary-card .value {
            font-size: 2rem;
            font-weight: 700;
            color: #667eea;
        }

        .summary-card .label {
            font-size: 0.85rem;
            color: #94a3b8;
            margin-top: 4px;
        }

        /* Download Section */
        .download-section {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 12px;
            padding: 24px;
            margin-top: 30px;
        }

        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .download-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .download-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .download-btn .file-name {
            font-weight: 600;
        }

        .download-btn .file-size {
            font-size: 0.8rem;
            color: #94a3b8;
        }

        .download-all-btn {
            display: block;
            width: 100%;
            padding: 16px;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .download-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }

        .hidden {
            display: none;
        }

        /* Data Preview */
        .preview-section {
            margin-top: 30px;
        }

        .preview-tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .preview-tab {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 6px;
            color: #94a3b8;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .preview-tab:hover,
        .preview-tab.active {
            background: #667eea;
            color: white;
        }

        .preview-content {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 16px;
            max-height: 400px;
            overflow: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <h1>üìä Comprehensive Statistics Data Generator</h1>
    <p class="subtitle">Analyzes GEDEvent_v25_1.csv and generates insightful data files for visualization</p>

    <!-- Progress Section -->
    <div class="status-section">
        <h2>üîÑ Processing Status</h2>
        <div id="progress">
            <div id="progress-bar"></div>
        </div>
        <div id="progress-text">Initializing...</div>
        <div class="log-container" id="log"></div>
    </div>

    <!-- Data Summary -->
    <div class="status-section hidden" id="summary-section">
        <h2>üìà Data Summary</h2>
        <div class="summary-grid" id="summary-grid"></div>
    </div>

    <!-- Download Section -->
    <div class="download-section hidden" id="download-section">
        <h2>üì• Download Generated Files</h2>
        <p style="color: #94a3b8; margin-bottom: 16px;">Save these files to your <code>data/</code> folder for optimized
            loading.</p>
        <div class="download-grid" id="download-buttons"></div>
        <button class="download-all-btn" onclick="downloadAll()">‚¨áÔ∏è Download All Files</button>
    </div>

    <!-- Data Preview -->
    <div class="preview-section hidden" id="preview-section">
        <h2>üëÅÔ∏è Data Preview</h2>
        <div class="preview-tabs" id="preview-tabs"></div>
        <div class="preview-content" id="preview-content">Select a file to preview...</div>
    </div>

    <script>
        // ====================================================
        // CONFIGURATION
        // ====================================================
        const CONFIG = {
            regions: ['Africa', 'Americas', 'Asia', 'Europe', 'Middle East'],
            regionColors: {
                'Africa': '#e74c3c',      // Red
                'Americas': '#9b59b6',    // Purple
                'Asia': '#f39c12',        // Orange-Yellow
                'Europe': '#3498db',      // Blue
                'Middle East': '#1abc9c'  // Teal
            },
            violenceTypes: {
                1: { name: 'State-based conflict', color: '#1f77b4' },
                2: { name: 'Non-state conflict', color: '#ff7f0e' },
                3: { name: 'One-sided violence', color: '#d62728' }
            }
        };

        // Storage for generated data
        const generatedFiles = {};
        let rawData = [];

        // ====================================================
        // LOGGING
        // ====================================================
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="time">[${time}]</span> ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateProgress(percent, text) {
            document.getElementById('progress-bar').style.width = `${percent}%`;
            document.getElementById('progress-text').textContent = text;
        }

        // ====================================================
        // DATA LOADING
        // ====================================================
        async function loadAndProcess() {
            try {
                log('Starting data processing...', 'info');
                updateProgress(5, 'Loading CSV file...');

                rawData = await d3.csv('../GEDEvent_v25_1.csv');
                log(`Loaded ${rawData.length} raw records from CSV`, 'success');
                updateProgress(15, 'Cleaning and filtering data...');

                // Clean and filter data
                rawData = rawData.map(d => ({
                    year: +d.year,
                    month: +d.date_start?.split('-')[1] || 1,
                    country: d.country,
                    region: d.region,
                    type_of_violence: +d.type_of_violence,
                    best: +d.best || 0,
                    high: +d.high || 0,
                    low: +d.low || 0,
                    deaths_a: +d.deaths_a || 0,
                    deaths_b: +d.deaths_b || 0,
                    deaths_civilians: +d.deaths_civilians || 0,
                    deaths_unknown: +d.deaths_unknown || 0
                })).filter(d =>
                    d.year >= 1989 &&
                    d.year <= 2023 &&
                    !isNaN(d.best) &&
                    CONFIG.regions.includes(d.region)
                );

                log(`Filtered to ${rawData.length} valid events (1989-2023, known regions)`, 'success');

                // Generate all datasets
                await generateAllDatasets();

                // Show summary and downloads
                showSummary();
                showDownloadButtons();
                setupPreview();

                log('‚úÖ All data files generated successfully!', 'success');
                updateProgress(100, 'Complete! Download your files below.');

            } catch (error) {
                log(`‚ùå Error: ${error.message}`, 'error');
                console.error(error);
                updateProgress(0, 'Error occurred. Check console for details.');
            }
        }

        // ====================================================
        // DATA GENERATION
        // ====================================================
        async function generateAllDatasets() {
            // 1. Histogram Data
            updateProgress(25, 'Generating histogram data...');
            generatedFiles['histogram_data.json'] = generateHistogramData();
            log('Generated histogram_data.json', 'success');

            // 2. Box Plot Data
            updateProgress(35, 'Generating box plot data...');
            generatedFiles['boxplot_data.json'] = generateBoxPlotData();
            log('Generated boxplot_data.json', 'success');

            // 3. Violin Plot Data
            updateProgress(45, 'Generating violin plot data...');
            generatedFiles['violin_data.json'] = generateViolinData();
            log('Generated violin_data.json', 'success');

            // 4. Heatmap Data
            updateProgress(55, 'Generating heatmap data...');
            generatedFiles['heatmap_data.json'] = generateHeatmapData();
            log('Generated heatmap_data.json', 'success');

            // 5. Stacked Bar Data
            updateProgress(65, 'Generating stacked bar data...');
            generatedFiles['stacked_bar_data.json'] = generateStackedBarData();
            log('Generated stacked_bar_data.json', 'success');

            // 6. Waffle Chart Data
            updateProgress(70, 'Generating waffle chart data...');
            generatedFiles['waffle_data.json'] = generateWaffleData();
            log('Generated waffle_data.json', 'success');

            // 7. Top Countries Data
            updateProgress(75, 'Generating top countries data...');
            generatedFiles['top_countries.json'] = generateTopCountries();
            log('Generated top_countries.json', 'success');

            // 8. Yearly Trends Data
            updateProgress(80, 'Generating yearly trends data...');
            generatedFiles['yearly_trends.json'] = generateYearlyTrends();
            log('Generated yearly_trends.json', 'success');

            // 9. Regional Summary
            updateProgress(85, 'Generating regional summary...');
            generatedFiles['regional_summary.json'] = generateRegionalSummary();
            log('Generated regional_summary.json', 'success');

            // 10. Comprehensive Summary
            updateProgress(90, 'Generating comprehensive summary...');
            generatedFiles['summary_stats.json'] = generateSummaryStats();
            log('Generated summary_stats.json', 'success');

            // 11. Ridgeline Data (events per year by region)
            updateProgress(92, 'Generating ridgeline data...');
            generatedFiles['ridgeline_data.json'] = generateRidgelineData();
            log('Generated ridgeline_data.json', 'success');

            // 12. Timeline Area Data (for timeline area chart with uncertainty)
            updateProgress(93, 'Generating timeline area data...');
            generatedFiles['timeline_area_data.json'] = generateTimelineAreaData();
            log('Generated timeline_area_data.json', 'success');

            // 13. Lollipop Countries Data (top 15 countries by events)
            updateProgress(94, 'Generating lollipop countries data...');
            generatedFiles['lollipop_countries.json'] = generateLollipopCountries();
            log('Generated lollipop_countries.json', 'success');

            // 14. Parallel/Slope Regions Data (regional changes over time periods)
            updateProgress(95, 'Generating parallel regions data...');
            generatedFiles['parallel_regions.json'] = generateParallelRegions();
            log('Generated parallel_regions.json', 'success');

            // 15. Violence Waffle Data (violence type percentages)
            updateProgress(96, 'Generating violence waffle data...');
            generatedFiles['violence_waffle.json'] = generateViolenceWaffle();
            log('Generated violence_waffle.json', 'success');

            // 16. Diverging Violence Data (state-based vs one-sided by region)
            updateProgress(97, 'Generating diverging violence data...');
            generatedFiles['diverging_violence.json'] = generateDivergingViolence();
            log('Generated diverging_violence.json', 'success');

            // 17. Treemap Data (casualties by country)
            updateProgress(97.5, 'Generating treemap data...');
            generatedFiles['treemap_data.json'] = generateTreemapData();
            log('Generated treemap_data.json', 'success');

            // 18. Heatmap Monthly Data (events by year and month)
            updateProgress(98, 'Generating heatmap monthly data...');
            generatedFiles['heatmap_monthly.json'] = generateHeatmapMonthly();
            log('Generated heatmap_monthly.json', 'success');

            // 19. Bullet Regions Data (regional metrics)
            updateProgress(98.5, 'Generating bullet regions data...');
            generatedFiles['bullet_regions.json'] = generateBulletRegions();
            log('Generated bullet_regions.json', 'success');

            // 20. Dot Error Bars Data (95% CI by region)
            updateProgress(99, 'Generating dot error bars data...');
            generatedFiles['dot_error_bars.json'] = generateDotErrorBars();
            log('Generated dot_error_bars.json', 'success');

            // 21. 2D Waffle/Heatmap Data (time period x casualty range)
            updateProgress(99.5, 'Generating 2D waffle data...');
            generatedFiles['waffle_2d.json'] = generateWaffle2D();
            log('Generated waffle_2d.json', 'success');
        }

        // Individual data generators
        function generateHistogramData() {
            const bins = [
                { label: '1-5', min: 1, max: 5 },
                { label: '6-10', min: 6, max: 10 },
                { label: '11-25', min: 11, max: 25 },
                { label: '26-50', min: 26, max: 50 },
                { label: '51-100', min: 51, max: 100 },
                { label: '101-250', min: 101, max: 250 },
                { label: '251-500', min: 251, max: 500 },
                { label: '501-1000', min: 501, max: 1000 },
                { label: '1000+', min: 1001, max: Infinity }
            ];

            return bins.map(bin => ({
                label: bin.label,
                count: rawData.filter(d => d.best >= bin.min && d.best <= bin.max).length,
                totalCasualties: rawData.filter(d => d.best >= bin.min && d.best <= bin.max)
                    .reduce((s, d) => s + d.best, 0)
            }));
        }

        function generateBoxPlotData() {
            return CONFIG.regions.map(region => {
                const values = rawData.filter(d => d.region === region).map(d => d.best).sort((a, b) => a - b);
                if (values.length === 0) return null;

                const q1 = d3.quantile(values, 0.25);
                const median = d3.quantile(values, 0.5);
                const q3 = d3.quantile(values, 0.75);
                const iqr = q3 - q1;

                return {
                    region,
                    count: values.length,
                    min: Math.max(d3.min(values), q1 - 1.5 * iqr),
                    q1, median, q3,
                    max: Math.min(d3.max(values), q3 + 1.5 * iqr),
                    mean: d3.mean(values),
                    totalCasualties: d3.sum(values),
                    color: CONFIG.regionColors[region]
                };
            }).filter(d => d);
        }

        function generateViolinData() {
            const yearBins = [
                { label: '1989-1994', min: 1989, max: 1994 },
                { label: '1995-1999', min: 1995, max: 1999 },
                { label: '2000-2004', min: 2000, max: 2004 },
                { label: '2005-2009', min: 2005, max: 2009 },
                { label: '2010-2014', min: 2010, max: 2014 },
                { label: '2015-2019', min: 2015, max: 2019 },
                { label: '2020-2023', min: 2020, max: 2023 }
            ];

            return yearBins.map(bin => {
                const events = rawData.filter(d => d.year >= bin.min && d.year <= bin.max);
                const values = events.map(d => Math.min(d.best, 100));

                return {
                    label: bin.label,
                    count: events.length,
                    values: values,
                    median: d3.median(values) || 0,
                    mean: d3.mean(values) || 0,
                    totalCasualties: events.reduce((s, d) => s + d.best, 0)
                };
            });
        }

        function generateHeatmapData() {
            const years = [...new Set(rawData.map(d => d.year))].sort((a, b) => a - b);

            const data = [];
            CONFIG.regions.forEach(region => {
                years.forEach(year => {
                    const events = rawData.filter(d => d.region === region && d.year === year);
                    data.push({
                        region, year,
                        count: events.length,
                        casualties: events.reduce((s, d) => s + d.best, 0)
                    });
                });
            });

            return {
                regions: CONFIG.regions,
                years: years,
                data: data,
                maxCount: Math.max(...data.map(d => d.count)),
                maxCasualties: Math.max(...data.map(d => d.casualties))
            };
        }

        function generateStackedBarData() {
            const years = [...new Set(rawData.map(d => d.year))].sort((a, b) => a - b);

            return {
                years: years,
                regions: CONFIG.regions,
                regionColors: CONFIG.regionColors,
                data: years.map(year => {
                    const row = { year };
                    CONFIG.regions.forEach(region => {
                        const events = rawData.filter(d => d.year === year && d.region === region);
                        row[region] = events.length;
                        row[region + '_casualties'] = events.reduce((s, d) => s + d.best, 0);
                    });
                    row.total = CONFIG.regions.reduce((s, r) => s + (row[r] || 0), 0);
                    return row;
                })
            };
        }

        function generateWaffleData() {
            // Generate triangular waffle data matching statistics.js
            const gridSize = 10;
            const casualtyThresholds = [0, 1, 3, 5, 10, 20, 50, 100, 200, 500];
            const startYear = 1989, endYear = 2023;
            const yearsPerRow = Math.ceil((endYear - startYear + 1) / gridSize);

            const yearRanges = [];
            for (let i = 0; i < gridSize; i++) {
                const start = startYear + i * yearsPerRow;
                const end = Math.min(start + yearsPerRow - 1, endYear);
                if (start <= endYear) {
                    yearRanges.push({ start, end, label: `${start}-${end}` });
                }
            }

            const gridData = [];
            for (let row = 0; row < gridSize; row++) {
                const numCells = gridSize - row;
                for (let col = 0; col < numCells; col++) {
                    const casualtyMin = casualtyThresholds[col] || 0;
                    const casualtyMax = casualtyThresholds[col + 1] || Infinity;
                    const yearRange = yearRanges[row] || { start: startYear, end: endYear };

                    const events = rawData.filter(d =>
                        d.best >= casualtyMin &&
                        d.best < casualtyMax &&
                        d.year >= yearRange.start &&
                        d.year <= yearRange.end
                    );

                    const regionCounts = {};
                    CONFIG.regions.forEach(r => regionCounts[r] = 0);
                    events.forEach(e => {
                        if (regionCounts[e.region] !== undefined) {
                            regionCounts[e.region]++;
                        }
                    });

                    let dominantRegion = null;
                    let maxCount = 0;
                    CONFIG.regions.forEach(r => {
                        if (regionCounts[r] > maxCount) {
                            maxCount = regionCounts[r];
                            dominantRegion = r;
                        }
                    });

                    gridData.push({
                        row, col,
                        casualtyRange: `${casualtyMin}-${casualtyMax === Infinity ? '+' : casualtyMax}`,
                        yearRange: yearRange.label,
                        events: events.length,
                        dominantRegion,
                        regionCounts,
                        color: dominantRegion ? CONFIG.regionColors[dominantRegion] : '#ccc'
                    });
                }
            }

            return {
                gridSize,
                casualtyThresholds,
                yearRanges,
                gridData,
                regions: CONFIG.regions,
                regionColors: CONFIG.regionColors
            };
        }

        function generateTopCountries() {
            const countryCounts = {};
            rawData.forEach(d => {
                if (!countryCounts[d.country]) {
                    countryCounts[d.country] = { events: 0, casualties: 0, region: d.region };
                }
                countryCounts[d.country].events++;
                countryCounts[d.country].casualties += d.best;
            });

            return Object.entries(countryCounts)
                .map(([country, data]) => ({
                    country,
                    events: data.events,
                    casualties: data.casualties,
                    avgCasualties: data.casualties / data.events,
                    region: data.region,
                    color: CONFIG.regionColors[data.region]
                }))
                .sort((a, b) => b.events - a.events)
                .slice(0, 30);
        }

        function generateYearlyTrends() {
            const years = [...new Set(rawData.map(d => d.year))].sort((a, b) => a - b);

            return years.map(year => {
                const events = rawData.filter(d => d.year === year);
                return {
                    year,
                    events: events.length,
                    casualties: events.reduce((s, d) => s + d.best, 0),
                    avgCasualties: events.length > 0 ? events.reduce((s, d) => s + d.best, 0) / events.length : 0,
                    byViolenceType: {
                        stateBased: events.filter(d => d.type_of_violence === 1).length,
                        nonState: events.filter(d => d.type_of_violence === 2).length,
                        oneSided: events.filter(d => d.type_of_violence === 3).length
                    }
                };
            });
        }

        function generateRegionalSummary() {
            return CONFIG.regions.map(region => {
                const events = rawData.filter(d => d.region === region);
                const years = [...new Set(events.map(d => d.year))].sort((a, b) => a - b);

                return {
                    region,
                    color: CONFIG.regionColors[region],
                    totalEvents: events.length,
                    totalCasualties: events.reduce((s, d) => s + d.best, 0),
                    avgCasualtiesPerEvent: events.length > 0 ? events.reduce((s, d) => s + d.best, 0) / events.length : 0,
                    yearRange: { min: Math.min(...years), max: Math.max(...years) },
                    countriesAffected: [...new Set(events.map(d => d.country))].length,
                    topCountries: Object.entries(
                        events.reduce((acc, d) => { acc[d.country] = (acc[d.country] || 0) + 1; return acc; }, {})
                    ).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([c, n]) => ({ country: c, events: n })),
                    violenceTypeBreakdown: {
                        stateBased: events.filter(d => d.type_of_violence === 1).length,
                        nonState: events.filter(d => d.type_of_violence === 2).length,
                        oneSided: events.filter(d => d.type_of_violence === 3).length
                    }
                };
            });
        }

        function generateSummaryStats() {
            const years = [...new Set(rawData.map(d => d.year))];
            const deadliestYear = years.reduce((max, y) => {
                const casualties = rawData.filter(d => d.year === y).reduce((s, d) => s + d.best, 0);
                return casualties > max.casualties ? { year: y, casualties } : max;
            }, { year: null, casualties: 0 });

            const mostActiveYear = years.reduce((max, y) => {
                const events = rawData.filter(d => d.year === y).length;
                return events > max.events ? { year: y, events } : max;
            }, { year: null, events: 0 });

            return {
                totalEvents: rawData.length,
                totalCasualties: rawData.reduce((s, d) => s + d.best, 0),
                avgCasualtiesPerEvent: rawData.reduce((s, d) => s + d.best, 0) / rawData.length,
                yearRange: { min: Math.min(...years), max: Math.max(...years) },
                regionsCount: CONFIG.regions.length,
                countriesCount: [...new Set(rawData.map(d => d.country))].length,
                deadliestYear,
                mostActiveYear,
                generated: new Date().toISOString()
            };
        }

        function generateRidgelineData() {
            // Events per year distribution by region (for ridgeline chart)
            const years = [...new Set(rawData.map(d => d.year))].sort((a, b) => a - b);

            return {
                years,
                regions: CONFIG.regions,
                regionColors: CONFIG.regionColors,
                data: CONFIG.regions.map(region => {
                    const regionData = rawData.filter(d => d.region === region);
                    const yearCounts = years.map(year => ({
                        year,
                        count: regionData.filter(d => d.year === year).length
                    }));
                    const maxCount = Math.max(...yearCounts.map(d => d.count));

                    return {
                        region,
                        color: CONFIG.regionColors[region],
                        yearCounts,
                        maxCount,
                    };
                })
            };
        }

        // Timeline Area Data - yearly events/casualties with uncertainty
        function generateTimelineAreaData() {
            const yearStart = 1989, yearEnd = 2023;
            const years = [];
            for (let y = yearStart; y <= yearEnd; y++) years.push(y);

            // Generate data for 'All' and each region
            const result = {
                years,
                regions: ['All', ...CONFIG.regions],
                regionColors: { 'All': '#6b7280', ...CONFIG.regionColors },
                data: {}
            };

            ['All', ...CONFIG.regions].forEach(region => {
                const filteredData = region === 'All'
                    ? rawData
                    : rawData.filter(d => d.region === region);

                result.data[region] = years.map(year => {
                    const events = filteredData.filter(d => d.year === year);
                    return {
                        year,
                        events: events.length,
                        casualties: events.reduce((s, d) => s + d.best, 0),
                        low: events.reduce((s, d) => s + d.low, 0),
                        high: events.reduce((s, d) => s + d.high, 0)
                    };
                });
            });

            return result;
        }

        // Lollipop Countries Data - top 15 countries by events
        function generateLollipopCountries() {
            const countryMap = {};
            rawData.forEach(d => {
                if (!countryMap[d.country]) {
                    countryMap[d.country] = { events: 0, casualties: 0, region: d.region };
                }
                countryMap[d.country].events++;
                countryMap[d.country].casualties += d.best;
            });

            return Object.entries(countryMap)
                .map(([country, data]) => ({
                    country,
                    events: data.events,
                    casualties: data.casualties,
                    avgCasualties: data.casualties / data.events,
                    region: data.region,
                    color: CONFIG.regionColors[data.region]
                }))
                .sort((a, b) => b.events - a.events)
                .slice(0, 15);
        }

        // Parallel/Slope Regions Data - regional changes over time periods
        function generateParallelRegions() {
            const periods = [
                { label: '89-94', start: 1989, end: 1994 },
                { label: '95-99', start: 1995, end: 1999 },
                { label: '00-04', start: 2000, end: 2004 },
                { label: '05-09', start: 2005, end: 2009 },
                { label: '10-14', start: 2010, end: 2014 },
                { label: '15-19', start: 2015, end: 2019 },
                { label: '20-23', start: 2020, end: 2023 }
            ];

            const data = CONFIG.regions.map(region => {
                const regionData = rawData.filter(d => d.region === region);
                const values = periods.map(period => {
                    const periodYears = period.end - period.start + 1;
                    const count = regionData.filter(d => d.year >= period.start && d.year <= period.end).length;
                    return Math.round(count / periodYears);
                });
                return { region, values, color: CONFIG.regionColors[region] };
            });

            return {
                periods: periods.map(p => p.label),
                regions: CONFIG.regions,
                regionColors: CONFIG.regionColors,
                data,
                maxValue: Math.max(...data.flatMap(d => d.values))
            };
        }

        // Violence Waffle Data - violence type percentages for waffle chart
        function generateViolenceWaffle() {
            const violenceTypes = {
                1: { name: 'State-based conflict', color: '#1f77b4' },
                2: { name: 'Non-state conflict', color: '#ff7f0e' },
                3: { name: 'One-sided violence', color: '#d62728' }
            };

            const total = rawData.length;
            const result = [];

            [1, 2, 3].forEach(type => {
                const typeEvents = rawData.filter(d => d.type_of_violence === type);
                const count = typeEvents.length;
                const casualties = typeEvents.reduce((s, d) => s + d.best, 0);
                result.push({
                    type,
                    name: violenceTypes[type].name,
                    color: violenceTypes[type].color,
                    count,
                    casualties,
                    percentage: (count / total) * 100
                });
            });

            return result;
        }

        // Diverging Violence Data - state-based vs one-sided by region
        function generateDivergingViolence() {
            return CONFIG.regions.map(region => {
                const events = rawData.filter(d => d.region === region);
                const stateBased = events.filter(d => d.type_of_violence === 1).length;
                const nonState = events.filter(d => d.type_of_violence === 2).length;
                const oneSided = events.filter(d => d.type_of_violence === 3).length;
                return {
                    region,
                    stateBased,
                    nonState,
                    oneSided,
                    color: CONFIG.regionColors[region]
                };
            });
        }

        // Treemap Data - casualties by country (top 20)
        function generateTreemapData() {
            const countryMap = {};
            rawData.forEach(d => {
                if (!countryMap[d.country]) {
                    countryMap[d.country] = { casualties: 0, region: d.region };
                }
                countryMap[d.country].casualties += d.best;
            });

            return Object.entries(countryMap)
                .map(([name, data]) => ({
                    name,
                    value: data.casualties,
                    region: data.region,
                    color: CONFIG.regionColors[data.region]
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 20);
        }

        // Heatmap Monthly Data - events by year and month
        function generateHeatmapMonthly() {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const yearStart = 1989, yearEnd = 2023;
            const years = [];
            for (let y = yearStart; y <= yearEnd; y++) years.push(y);

            // Generate data for 'All' and each region
            const result = {
                years,
                months,
                regions: ['All', ...CONFIG.regions],
                regionColors: { 'All': '#6b7280', ...CONFIG.regionColors },
                data: {}
            };

            ['All', ...CONFIG.regions].forEach(region => {
                const filteredData = region === 'All'
                    ? rawData
                    : rawData.filter(d => d.region === region);

                const heatData = [];
                years.forEach(year => {
                    months.forEach((month, mi) => {
                        const count = filteredData.filter(d => d.year === year && d.month === mi + 1).length;
                        heatData.push({ year, month: mi + 1, monthName: month, count });
                    });
                });
                result.data[region] = heatData;
            });

            result.maxCount = Math.max(...Object.values(result.data).flat().map(d => d.count));

            return result;
        }

        // Bullet Regions Data - regional metrics (recent, avg, trend)
        function generateBulletRegions() {
            const yearStart = 1989, yearEnd = 2023;
            const totalYears = yearEnd - yearStart + 1;

            return CONFIG.regions.map(region => {
                const all = rawData.filter(d => d.region === region);
                const recent = all.filter(d => d.year === 2023).length;
                const avg = all.length / totalYears;
                const trend = all.filter(d => d.year >= 2019).length / 5; // 5-year average
                return {
                    region,
                    recent,
                    avg,
                    trend,
                    total: all.length,
                    color: CONFIG.regionColors[region]
                };
            });
        }

        // Dot Error Bars Data - average casualties with 95% CI by region
        function generateDotErrorBars() {
            return CONFIG.regions.map(region => {
                const values = rawData.filter(d => d.region === region).map(d => d.best);
                const n = values.length;
                if (n === 0) return null;

                const mean = values.reduce((s, v) => s + v, 0) / n;
                const variance = values.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / (n - 1);
                const std = Math.sqrt(variance);
                const se = std / Math.sqrt(n);
                const ci95 = se * 1.96;

                return {
                    region,
                    mean,
                    low: Math.max(0, mean - ci95),
                    high: mean + ci95,
                    n,
                    std,
                    se,
                    color: CONFIG.regionColors[region]
                };
            }).filter(d => d !== null);
        }

        // 2D Waffle/Heatmap Data - time period x casualty range
        function generateWaffle2D() {
            const casualtyRanges = [
                { label: '0', min: 0, max: 0 },
                { label: '1-5', min: 1, max: 5 },
                { label: '6-10', min: 6, max: 10 },
                { label: '11-25', min: 11, max: 25 },
                { label: '26-50', min: 26, max: 50 },
                { label: '51-100', min: 51, max: 100 },
                { label: '101-200', min: 101, max: 200 },
                { label: '201-500', min: 201, max: 500 },
                { label: '500+', min: 501, max: Infinity }
            ];

            const timePeriods = [
                { label: '1989-1993', start: 1989, end: 1993 },
                { label: '1994-1998', start: 1994, end: 1998 },
                { label: '1999-2003', start: 1999, end: 2003 },
                { label: '2004-2008', start: 2004, end: 2008 },
                { label: '2009-2013', start: 2009, end: 2013 },
                { label: '2014-2018', start: 2014, end: 2018 },
                { label: '2019-2023', start: 2019, end: 2023 }
            ];

            const gridData = [];
            let maxEvents = 0;

            timePeriods.forEach((period, row) => {
                casualtyRanges.forEach((range, col) => {
                    const events = rawData.filter(d =>
                        d.year >= period.start &&
                        d.year <= period.end &&
                        d.best >= range.min &&
                        d.best <= range.max
                    );

                    const count = events.length;
                    if (count > maxEvents) maxEvents = count;

                    // Count by region
                    const regionCounts = {};
                    CONFIG.regions.forEach(r => regionCounts[r] = 0);
                    events.forEach(e => {
                        if (regionCounts[e.region] !== undefined) {
                            regionCounts[e.region]++;
                        }
                    });

                    gridData.push({
                        row, col,
                        count,
                        period: period.label,
                        casualty: range.label,
                        regionCounts
                    });
                });
            });

            return {
                timePeriods: timePeriods.map(p => p.label),
                casualtyRanges: casualtyRanges.map(r => r.label),
                regions: CONFIG.regions,
                regionColors: CONFIG.regionColors,
                gridData,
                maxEvents
            };
        }

        // ====================================================
        // UI FUNCTIONS
        // ====================================================
        function showSummary() {
            const section = document.getElementById('summary-section');
            const grid = document.getElementById('summary-grid');
            section.classList.remove('hidden');

            const stats = generatedFiles['summary_stats.json'];
            const cards = [
                { value: stats.totalEvents.toLocaleString(), label: 'Total Events' },
                { value: stats.totalCasualties.toLocaleString(), label: 'Total Casualties' },
                { value: stats.countriesCount, label: 'Countries Affected' },
                { value: stats.avgCasualtiesPerEvent.toFixed(1), label: 'Avg Casualties/Event' },
                { value: stats.deadliestYear.year, label: 'Deadliest Year' },
                { value: stats.mostActiveYear.year, label: 'Most Active Year' }
            ];

            grid.innerHTML = cards.map(c => `
                <div class="summary-card">
                    <div class="value">${c.value}</div>
                    <div class="label">${c.label}</div>
                </div>
            `).join('');
        }

        function showDownloadButtons() {
            const section = document.getElementById('download-section');
            const buttonsDiv = document.getElementById('download-buttons');
            section.classList.remove('hidden');

            buttonsDiv.innerHTML = Object.entries(generatedFiles).map(([filename, data]) => {
                const size = JSON.stringify(data).length;
                const sizeStr = size > 1024 ? (size / 1024).toFixed(1) + ' KB' : size + ' B';
                return `
                    <button class="download-btn" onclick="downloadFile('${filename}')">
                        <span class="file-name">üìÑ ${filename}</span>
                        <span class="file-size">${sizeStr}</span>
                    </button>
                `;
            }).join('');
        }

        function setupPreview() {
            const section = document.getElementById('preview-section');
            const tabs = document.getElementById('preview-tabs');
            section.classList.remove('hidden');

            tabs.innerHTML = Object.keys(generatedFiles).map(filename =>
                `<button class="preview-tab" onclick="previewFile('${filename}')">${filename.replace('.json', '')}</button>`
            ).join('');
        }

        function previewFile(filename) {
            document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            const data = generatedFiles[filename];
            document.getElementById('preview-content').textContent = JSON.stringify(data, null, 2);
        }

        function downloadFile(filename) {
            const data = generatedFiles[filename];
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            log(`Downloaded: ${filename}`, 'success');
        }

        function downloadAll() {
            Object.keys(generatedFiles).forEach((filename, idx) => {
                setTimeout(() => downloadFile(filename), idx * 300);
            });
        }

        // Start processing
        document.addEventListener('DOMContentLoaded', loadAndProcess);
    </script>
</body>

</html>